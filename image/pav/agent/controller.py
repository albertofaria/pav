# ---------------------------------------------------------------------------- #

from __future__ import annotations

from asyncio import create_task
from collections.abc import AsyncIterator, Callable, Mapping
from http import HTTPStatus
from pathlib import Path
from typing import Any, Optional, Union

import kopf
import yaml
from grpc import StatusCode  # type: ignore
from kubernetes_asyncio.client import (  # type: ignore
    ApiClient,
    ApiException,
    StorageV1Api,
    V1CSIDriver,
    V1PersistentVolumeClaim,
    V1Pod,
)
from kubernetes_asyncio.utils.create_from_yaml import (  # type: ignore
    create_from_yaml_single_item,
)

from pav.agent.common import (
    VolumeProvisioningContext,
    VolumeProvisioningHandler,
    handle_volume_provisioning,
)
from pav.shared.config import (
    AGENT_HANDLER_RETRY_DELAY,
    DOMAIN,
    INTERNAL_NAMESPACE,
    KOPF_FINALIZER,
    PROVISIONER_GROUP,
    PROVISIONER_KIND,
    PROVISIONER_VERSION,
)
from pav.shared.kubernetes import (
    atomically_modify_persistent_volume_claim,
    get_all_persistent_volume_claims,
    get_all_pods,
    synchronously_delete_csi_driver,
)
from pav.shared.provisioner import Provisioner, RequestedVolumeProperties
from pav.shared.states import VolumeProvisioningState, VolumeProvisioningStates

# ---------------------------------------------------------------------------- #


def run(image: str) -> None:

    # create Kubernetes API client object

    api_client = ApiClient()

    # define handlers

    registry = kopf.OperatorRegistry()

    _define_operator_handlers(registry, api_client)
    _define_webhook_handlers(registry)
    _define_provisioner_handlers(registry, api_client, image)
    _define_volume_provisioning_handlers(registry, api_client)

    # run kopf

    kopf.configure()
    kopf.run(registry=registry, standalone=True, clusterwide=True)


# ---------------------------------------------------------------------------- #
# Webhook configuration and operator lifecycle


def _define_operator_handlers(
    registry: kopf.OperatorRegistry, api_client: ApiClient
) -> None:
    @kopf.on.login(registry=registry)
    async def on_login(**kwargs: Any) -> Optional[kopf.ConnectionInfo]:
        return kopf.login_via_client(**kwargs)

    @kopf.on.startup(registry=registry)
    async def on_startup(settings: kopf.OperatorSettings, **_: object) -> None:

        # use custom finalizer

        settings.persistence.finalizer = KOPF_FINALIZER

        # don't create events

        settings.posting.enabled = False

        # configure webhooks

        settings.admission.server = _CustomWebhookServer()
        settings.admission.managed = DOMAIN

        # launch task that watches PVCs

        provisioning_coroutine = handle_volume_provisioning(
            api_client, _provisioning_handlers
        )

        create_task(provisioning_coroutine)


# ---------------------------------------------------------------------------- #
# Webhooks


class _CustomWebhookServer(kopf.WebhookServer):
    def __init__(self) -> None:
        super().__init__(
            addr="0.0.0.0", port=443, host=f"webhooks.{INTERNAL_NAMESPACE}.svc"
        )

    async def __call__(
        self, fn: kopf.WebhookFn
    ) -> AsyncIterator[kopf.WebhookClientConfig]:

        # Override the config generated by the base WebhookServer, which points
        # the webhook at an URL, to instead point at the appropriate Service.

        async for config in super().__call__(fn):

            assert isinstance(config["url"], str)

            yield kopf.WebhookClientConfig(
                caBundle=config["caBundle"],
                service=kopf.WebhookClientConfigService(
                    name="webhooks",
                    namespace=INTERNAL_NAMESPACE,
                    port=443,
                    path=config["url"].removeprefix(f"https://{self.host}"),
                ),
            )


def _define_webhook_handlers(registry: kopf.OperatorRegistry) -> None:
    @kopf.on.validate(
        registry=registry,
        group=PROVISIONER_GROUP,
        version=PROVISIONER_VERSION,
        kind=PROVISIONER_KIND,
        persistent=True,
        id="validate",
    )
    async def validate(body: kopf.Body, **_: object) -> None:

        try:
            Provisioner.validate(body)
        except ValueError as e:
            raise kopf.AdmissionError(str(e), code=HTTPStatus.BAD_REQUEST)


# ---------------------------------------------------------------------------- #
# Provisioner creation and deletion


def _define_provisioner_handlers(
    registry: kopf.OperatorRegistry, api_client: ApiClient, image: str
) -> None:

    base_dir = Path(__file__).parent

    template_csi_driver = (base_dir / "template-csi-driver.yaml").read_text()
    template_other = (base_dir / "template-other.yaml").read_text()

    @kopf.on.create(
        registry=registry,
        group=PROVISIONER_GROUP,
        version=PROVISIONER_VERSION,
        kind=PROVISIONER_KIND,
        backoff=AGENT_HANDLER_RETRY_DELAY.total_seconds(),
        id="on_provisioner_created",
    )
    async def on_provisioner_created(body: kopf.Body, **_: object) -> None:

        csi_driver = await create_csi_driver_object(provisioner=body)

        await create_other_objects(provisioner=body, csi_driver=csi_driver)

    async def create_csi_driver_object(
        provisioner: kopf.Body,
    ) -> V1CSIDriver:

        # instantiate template

        obj_yaml = template_csi_driver.format(provisioner=provisioner)
        obj = yaml.safe_load(obj_yaml)

        # create the CSIDriver object

        api = StorageV1Api(api_client)

        try:
            return await api.create_csi_driver(body=obj)
        except ApiException as e:
            if e.status == HTTPStatus.CONFLICT:
                return await api.read_csi_driver(name=obj["metadata"]["name"])
            else:
                raise

    async def create_other_objects(
        provisioner: kopf.Body, csi_driver: V1CSIDriver
    ) -> None:

        # instantiate template

        objs_yaml = template_other.format(provisioner=provisioner, image=image)
        objs = list(yaml.safe_load_all(objs_yaml))

        # create objects

        owner_ref = kopf.OwnerReference(
            controller=True,
            blockOwnerDeletion=True,
            apiVersion=csi_driver.api_version,
            kind=csi_driver.kind,
            name=csi_driver.metadata.name,
            uid=csi_driver.metadata.uid,
        )

        for obj in objs:

            # set the CSIDriver object as the owner

            obj["metadata"].setdefault("ownerReferences", []).append(owner_ref)

            # create the object

            try:
                await create_from_yaml_single_item(api_client, yml_object=obj)
            except ApiException as e:
                if e.status != HTTPStatus.CONFLICT:
                    raise

    @kopf.on.delete(
        registry=registry,
        group=PROVISIONER_GROUP,
        version=PROVISIONER_VERSION,
        kind=PROVISIONER_KIND,
        backoff=AGENT_HANDLER_RETRY_DELAY.total_seconds(),
        id="on_provisioner_deleted",
    )
    async def on_provisioner_deleted(body: kopf.Body, **_: object) -> None:

        # We want to delete the PavProvisioner when all of the following are
        # true:
        #
        #   - Deletion of the PavProvisioner has been requested (which prevents
        #     volumes from being provisioned and staged);
        #   - The PavProvisioner has no dynamically-provisioned volumes;
        #   - The PavProvisioner has no statically-provisioned volumes staged.

        has_dynamically_provisioned_volumes = bool(
            await get_all_persistent_volume_claims(
                api_client=api_client,
                label_selector=f"{DOMAIN}/provisioner={body.metadata.name}",
            )
        )

        has_staged_volumes = any(
            pod.status.phase not in ["Succeeded", "Failed"]
            for pod in await get_all_pods(
                api_client=api_client,
                label_selector=f"{DOMAIN}/uses-provisioner-{body.metadata.uid}",
            )
        )

        if has_dynamically_provisioned_volumes or has_staged_volumes:
            raise kopf.TemporaryError(
                "Can't delete PavProvisioner yet, will retry.",
                delay=AGENT_HANDLER_RETRY_DELAY.total_seconds(),
            )

        # delete CSI driver (which will cause deletion of everything else)

        assert body.metadata.name

        await synchronously_delete_csi_driver(
            api_client, name=body.metadata.name
        )


# ---------------------------------------------------------------------------- #
# Volume validation, creation, and deletion


def _define_volume_provisioning_handlers(
    registry: kopf.OperatorRegistry, api_client: ApiClient
) -> None:
    @kopf.on.delete(
        registry=registry,
        group="",
        version="v1",
        kind="PersistentVolumeClaim",
        labels={f"{DOMAIN}/provisioner": kopf.PRESENT},
        backoff=AGENT_HANDLER_RETRY_DELAY.total_seconds(),
        id="on_pvc_deleted",
    )
    async def on_pvc_deleted(body: kopf.Body, **_: object) -> None:

        # We want to delete the volume when all of the following are true:
        #
        #   - Deletion of the PVC has been requested (which prevents pods from
        #     staging it);
        #   - The volume isn't currently staged by any pod;
        #   - The only finalizer remaining on the PVC is PaV's.

        assert body.metadata.name
        assert body.metadata.namespace
        assert body.metadata.uid

        pvc_is_staged = any(
            pod.status.phase not in ["Succeeded", "Failed"]
            for pod in await get_all_pods(
                api_client=api_client,
                label_selector=f"{DOMAIN}/uses-volume-{body.metadata.uid}",
            )
        )

        finalizers = frozenset(body.metadata.get("finalizers", []))

        pvc_has_other_finalizers = not finalizers.issubset(
            {f"{DOMAIN}/delete-volume", KOPF_FINALIZER}
        )

        if pvc_is_staged or pvc_has_other_finalizers:
            raise kopf.TemporaryError(
                "Can't delete PVC yet, will retry.",
                delay=AGENT_HANDLER_RETRY_DELAY.total_seconds(),
            )

        # trigger volume deletion

        async def modifier(pvc: V1PersistentVolumeClaim) -> None:

            pvc.metadata.annotations |= {f"{DOMAIN}/deletion-requested": ""}

            state = VolumeProvisioningState.from_json(
                pvc.metadata.annotations[f"{DOMAIN}/state"]
            )

            if isinstance(state, VolumeProvisioningStates.Created):
                pvc.metadata.annotations |= {
                    f"{DOMAIN}/state": (
                        VolumeProvisioningStates.LaunchDeletionPod().to_json()
                    )
                }

        await atomically_modify_persistent_volume_claim(
            api_client=api_client,
            name=body.metadata.name,
            namespace=body.metadata.namespace,
            modifier=modifier,
        )


_provisioning_handlers: dict[
    type[VolumeProvisioningState], VolumeProvisioningHandler
] = {}


def _add_provisioning_handler(
    state_type: type[VolumeProvisioningState],
) -> Callable[[VolumeProvisioningHandler], VolumeProvisioningHandler]:
    def decorator(
        handler: VolumeProvisioningHandler,
    ) -> VolumeProvisioningHandler:
        _provisioning_handlers[state_type] = handler
        return handler

    return decorator


@_add_provisioning_handler(VolumeProvisioningStates.LaunchValidationPod)
async def _handle_launch_validation_pod(
    context: VolumeProvisioningContext,
    state: VolumeProvisioningStates.LaunchValidationPod,
) -> None:
    async def error(message: str) -> None:

        await context.set_state(
            VolumeProvisioningStates.CreationFailed(
                error_code=StatusCode.INVALID_ARGUMENT,
                error_details=message.strip(),
            )
        )

    # get validation config

    try:
        validation_config = await context.eval_dynamic_validation_config()
    except Exception as e:
        await error(str(e))
        return

    requested = RequestedVolumeProperties.from_pvc(context.pvc)

    # validate requested volume mode, access mode, minimum capacity, and
    # maximum capacity

    if requested.volume_mode not in validation_config.volume_modes:
        [supported_mode] = validation_config.volume_modes
        await error(
            f"PavProvisioner '{context.provisioner.name}' can only provision"
            f" volumes with volume mode {supported_mode.value}"
        )
        return

    if not requested.access_modes.issubset(validation_config.access_modes):
        assert len(validation_config.access_modes) <= 2
        await error(
            f"PavProvisioner '{context.provisioner.name}' can only provision"
            f" volumes supporting access mode"
            f" {' or '.join(m.value for m in validation_config.access_modes)}"
        )
        return

    if (
        validation_config.max_capacity is not None
        and requested.min_capacity > validation_config.max_capacity
    ):
        await error(
            f"PavProvisioner '{context.provisioner.name}' cannot provision"
            f" volumes with capacity greater than"
            f" {validation_config.max_capacity} bytes"
        )
        return

    if (
        requested.max_capacity is not None
        and requested.max_capacity < validation_config.min_capacity
    ):
        await error(
            f"PavProvisioner '{context.provisioner.name}' cannot provision"
            f" volumes with capacity lower than"
            f" {validation_config.min_capacity} bytes"
        )
        return

    # check if there is a validation pod

    if validation_config.pod_template is None:
        await context.set_state(VolumeProvisioningStates.LaunchCreationPod())
        return

    # create validation pod

    validation_pod = await validation_config.pod_template.create(
        pod_name=f"pav-volume-validation-pod-{context.pvc.metadata.uid}"
    )

    # wait until validation pod is scheduled to a node

    node_name = await validation_pod.wait_until_scheduled()

    # advance state

    await context.set_state(
        VolumeProvisioningStates.AwaitValidationPod(
            validation_pod_namespace=validation_pod.namespace
        ),
        handler_node_name=node_name,
    )


@_add_provisioning_handler(VolumeProvisioningStates.LaunchCreationPod)
async def _handle_launch_creation_pod(
    context: VolumeProvisioningContext,
    state: VolumeProvisioningStates.LaunchCreationPod,
) -> None:
    async def error(message: str) -> None:

        await context.set_state(
            VolumeProvisioningStates.CreationFailed(
                error_code=StatusCode.INVALID_ARGUMENT,
                error_details=message.strip(),
            )
        )

    # get creation config

    try:
        creation_config = await context.eval_creation_config()
    except Exception as e:
        await error(str(e))
        return

    # check if there is a creation pod

    if creation_config.pod_template is None:

        # get volume handle

        if creation_config.handle is not None:
            handle = creation_config.handle
        else:
            handle = f"pvc-{context.pvc.metadata.uid}"

        # get volume capacity

        if creation_config.capacity is None:
            await error(
                f"No creation pod template and no volume capacity specified in"
                f" the PavProvisioner"
            )
            return

        # advance state

        await context.set_state(
            VolumeProvisioningStates.Created(
                handle=handle, capacity=creation_config.capacity
            )
        )

        return

    # create creation pod

    creation_pod = await creation_config.pod_template.create(
        pod_name=f"pav-volume-creation-pod-{context.pvc.metadata.uid}"
    )

    # wait for creation pod to be scheduled to a node

    node_name = await creation_pod.wait_until_scheduled()

    # advance state

    await context.set_state(
        VolumeProvisioningStates.AwaitCreationPod(
            creation_pod_namespace=creation_pod.namespace,
            handle=creation_config.handle,
            capacity=creation_config.capacity,
        ),
        handler_node_name=node_name,
    )


@_add_provisioning_handler(VolumeProvisioningStates.LaunchDeletionPod)
@_add_provisioning_handler(
    VolumeProvisioningStates.LaunchDeletionPodAfterFailure
)
async def _handle_launch_deletion_pod(
    context: VolumeProvisioningContext,
    state: Union[
        VolumeProvisioningStates.LaunchDeletionPod,
        VolumeProvisioningStates.LaunchDeletionPodAfterFailure,
    ],
) -> None:

    # get deletion config

    try:
        deletion_config = await context.eval_deletion_config()
    except Exception as e:
        await context.set_state(
            VolumeProvisioningStates.UnrecoverableFailure(
                error_code=StatusCode.INVALID_ARGUMENT, error_details=str(e)
            )
        )
        return

    # check if there is a deletion pod

    if deletion_config.pod_template is None:

        if isinstance(state, VolumeProvisioningStates.LaunchDeletionPod):
            await context.set_state(VolumeProvisioningStates.Deleted())
        else:
            await context.set_state(
                VolumeProvisioningStates.CreationFailed(
                    error_code=state.error_code,
                    error_details=state.error_details,
                )
            )

        return

    # create deletion pod

    try:
        deletion_pod = await deletion_config.pod_template.create(
            pod_name=f"pav-volume-deletion-pod-{context.pvc.metadata.uid}"
        )
    except Exception as e:
        await context.set_state(
            VolumeProvisioningStates.UnrecoverableFailure(
                error_code=StatusCode.INVALID_ARGUMENT, error_details=str(e)
            )
        )
        return

    # wait for deletion pod to be scheduled to a node

    node_name = await deletion_pod.wait_until_scheduled()

    # advance state

    if isinstance(state, VolumeProvisioningStates.LaunchDeletionPod):
        await context.set_state(
            VolumeProvisioningStates.AwaitDeletionPod(
                deletion_pod_namespace=deletion_pod.namespace
            ),
            handler_node_name=node_name,
        )
    else:
        await context.set_state(
            VolumeProvisioningStates.AwaitDeletionPodAfterFailure(
                deletion_pod_namespace=deletion_pod.namespace,
                error_code=state.error_code,
                error_details=state.error_details,
            ),
            handler_node_name=node_name,
        )


# ---------------------------------------------------------------------------- #
