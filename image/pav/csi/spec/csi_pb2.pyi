"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.descriptor_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.internal.extension_dict
import google.protobuf.message
import google.protobuf.timestamp_pb2
import google.protobuf.wrappers_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class GetPluginInfoRequest(google.protobuf.message.Message):
    """Intentionally empty."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___GetPluginInfoRequest = GetPluginInfoRequest

class GetPluginInfoResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class ManifestEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    VENDOR_VERSION_FIELD_NUMBER: builtins.int
    MANIFEST_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """The name MUST follow domain name notation format
    (https://tools.ietf.org/html/rfc1035#section-2.3.1). It SHOULD
    include the plugin's host company name and the plugin name,
    to minimize the possibility of collisions. It MUST be 63
    characters or less, beginning and ending with an alphanumeric
    character ([a-z0-9A-Z]) with dashes (-), dots (.), and
    alphanumerics between. This field is REQUIRED.
    """

    vendor_version: typing.Text = ...
    """This field is REQUIRED. Value of this field is opaque to the CO."""

    @property
    def manifest(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """This field is OPTIONAL. Values are opaque to the CO."""
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        vendor_version : typing.Text = ...,
        manifest : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["manifest",b"manifest","name",b"name","vendor_version",b"vendor_version"]) -> None: ...
global___GetPluginInfoResponse = GetPluginInfoResponse

class GetPluginCapabilitiesRequest(google.protobuf.message.Message):
    """Intentionally empty."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___GetPluginCapabilitiesRequest = GetPluginCapabilitiesRequest

class GetPluginCapabilitiesResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CAPABILITIES_FIELD_NUMBER: builtins.int
    @property
    def capabilities(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PluginCapability]:
        """All the capabilities that the controller service supports. This
        field is OPTIONAL.
        """
        pass
    def __init__(self,
        *,
        capabilities : typing.Optional[typing.Iterable[global___PluginCapability]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["capabilities",b"capabilities"]) -> None: ...
global___GetPluginCapabilitiesResponse = GetPluginCapabilitiesResponse

class PluginCapability(google.protobuf.message.Message):
    """Specifies a capability of the plugin."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Service(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class Type(_Type, metaclass=_TypeEnumTypeWrapper):
            pass
        class _Type:
            V = typing.NewType('V', builtins.int)
        class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Type.V], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
            UNKNOWN = PluginCapability.Service.Type.V(0)
            CONTROLLER_SERVICE = PluginCapability.Service.Type.V(1)
            """CONTROLLER_SERVICE indicates that the Plugin provides RPCs for
            the ControllerService. Plugins SHOULD provide this capability.
            In rare cases certain plugins MAY wish to omit the
            ControllerService entirely from their implementation, but such
            SHOULD NOT be the common case.
            The presence of this capability determines whether the CO will
            attempt to invoke the REQUIRED ControllerService RPCs, as well
            as specific RPCs as indicated by ControllerGetCapabilities.
            """

            VOLUME_ACCESSIBILITY_CONSTRAINTS = PluginCapability.Service.Type.V(2)
            """VOLUME_ACCESSIBILITY_CONSTRAINTS indicates that the volumes for
            this plugin MAY NOT be equally accessible by all nodes in the
            cluster. The CO MUST use the topology information returned by
            CreateVolumeRequest along with the topology information
            returned by NodeGetInfo to ensure that a given volume is
            accessible from a given node when scheduling workloads.
            """


        UNKNOWN = PluginCapability.Service.Type.V(0)
        CONTROLLER_SERVICE = PluginCapability.Service.Type.V(1)
        """CONTROLLER_SERVICE indicates that the Plugin provides RPCs for
        the ControllerService. Plugins SHOULD provide this capability.
        In rare cases certain plugins MAY wish to omit the
        ControllerService entirely from their implementation, but such
        SHOULD NOT be the common case.
        The presence of this capability determines whether the CO will
        attempt to invoke the REQUIRED ControllerService RPCs, as well
        as specific RPCs as indicated by ControllerGetCapabilities.
        """

        VOLUME_ACCESSIBILITY_CONSTRAINTS = PluginCapability.Service.Type.V(2)
        """VOLUME_ACCESSIBILITY_CONSTRAINTS indicates that the volumes for
        this plugin MAY NOT be equally accessible by all nodes in the
        cluster. The CO MUST use the topology information returned by
        CreateVolumeRequest along with the topology information
        returned by NodeGetInfo to ensure that a given volume is
        accessible from a given node when scheduling workloads.
        """


        TYPE_FIELD_NUMBER: builtins.int
        type: global___PluginCapability.Service.Type.V = ...
        def __init__(self,
            *,
            type : global___PluginCapability.Service.Type.V = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["type",b"type"]) -> None: ...

    class VolumeExpansion(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class Type(_Type, metaclass=_TypeEnumTypeWrapper):
            pass
        class _Type:
            V = typing.NewType('V', builtins.int)
        class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Type.V], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
            UNKNOWN = PluginCapability.VolumeExpansion.Type.V(0)
            ONLINE = PluginCapability.VolumeExpansion.Type.V(1)
            """ONLINE indicates that volumes may be expanded when published to
            a node. When a Plugin implements this capability it MUST
            implement either the EXPAND_VOLUME controller capability or the
            EXPAND_VOLUME node capability or both. When a plugin supports
            ONLINE volume expansion and also has the EXPAND_VOLUME
            controller capability then the plugin MUST support expansion of
            volumes currently published and available on a node. When a
            plugin supports ONLINE volume expansion and also has the
            EXPAND_VOLUME node capability then the plugin MAY support
            expansion of node-published volume via NodeExpandVolume.

            Example 1: Given a shared filesystem volume (e.g. GlusterFs),
              the Plugin may set the ONLINE volume expansion capability and
              implement ControllerExpandVolume but not NodeExpandVolume.

            Example 2: Given a block storage volume type (e.g. EBS), the
              Plugin may set the ONLINE volume expansion capability and
              implement both ControllerExpandVolume and NodeExpandVolume.

            Example 3: Given a Plugin that supports volume expansion only
              upon a node, the Plugin may set the ONLINE volume
              expansion capability and implement NodeExpandVolume but not
              ControllerExpandVolume.
            """

            OFFLINE = PluginCapability.VolumeExpansion.Type.V(2)
            """OFFLINE indicates that volumes currently published and
            available on a node SHALL NOT be expanded via
            ControllerExpandVolume. When a plugin supports OFFLINE volume
            expansion it MUST implement either the EXPAND_VOLUME controller
            capability or both the EXPAND_VOLUME controller capability and
            the EXPAND_VOLUME node capability.

            Example 1: Given a block storage volume type (e.g. Azure Disk)
              that does not support expansion of "node-attached" (i.e.
              controller-published) volumes, the Plugin may indicate
              OFFLINE volume expansion support and implement both
              ControllerExpandVolume and NodeExpandVolume.
            """


        UNKNOWN = PluginCapability.VolumeExpansion.Type.V(0)
        ONLINE = PluginCapability.VolumeExpansion.Type.V(1)
        """ONLINE indicates that volumes may be expanded when published to
        a node. When a Plugin implements this capability it MUST
        implement either the EXPAND_VOLUME controller capability or the
        EXPAND_VOLUME node capability or both. When a plugin supports
        ONLINE volume expansion and also has the EXPAND_VOLUME
        controller capability then the plugin MUST support expansion of
        volumes currently published and available on a node. When a
        plugin supports ONLINE volume expansion and also has the
        EXPAND_VOLUME node capability then the plugin MAY support
        expansion of node-published volume via NodeExpandVolume.

        Example 1: Given a shared filesystem volume (e.g. GlusterFs),
          the Plugin may set the ONLINE volume expansion capability and
          implement ControllerExpandVolume but not NodeExpandVolume.

        Example 2: Given a block storage volume type (e.g. EBS), the
          Plugin may set the ONLINE volume expansion capability and
          implement both ControllerExpandVolume and NodeExpandVolume.

        Example 3: Given a Plugin that supports volume expansion only
          upon a node, the Plugin may set the ONLINE volume
          expansion capability and implement NodeExpandVolume but not
          ControllerExpandVolume.
        """

        OFFLINE = PluginCapability.VolumeExpansion.Type.V(2)
        """OFFLINE indicates that volumes currently published and
        available on a node SHALL NOT be expanded via
        ControllerExpandVolume. When a plugin supports OFFLINE volume
        expansion it MUST implement either the EXPAND_VOLUME controller
        capability or both the EXPAND_VOLUME controller capability and
        the EXPAND_VOLUME node capability.

        Example 1: Given a block storage volume type (e.g. Azure Disk)
          that does not support expansion of "node-attached" (i.e.
          controller-published) volumes, the Plugin may indicate
          OFFLINE volume expansion support and implement both
          ControllerExpandVolume and NodeExpandVolume.
        """


        TYPE_FIELD_NUMBER: builtins.int
        type: global___PluginCapability.VolumeExpansion.Type.V = ...
        def __init__(self,
            *,
            type : global___PluginCapability.VolumeExpansion.Type.V = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["type",b"type"]) -> None: ...

    SERVICE_FIELD_NUMBER: builtins.int
    VOLUME_EXPANSION_FIELD_NUMBER: builtins.int
    @property
    def service(self) -> global___PluginCapability.Service:
        """Service that the plugin supports."""
        pass
    @property
    def volume_expansion(self) -> global___PluginCapability.VolumeExpansion: ...
    def __init__(self,
        *,
        service : typing.Optional[global___PluginCapability.Service] = ...,
        volume_expansion : typing.Optional[global___PluginCapability.VolumeExpansion] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["service",b"service","type",b"type","volume_expansion",b"volume_expansion"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["service",b"service","type",b"type","volume_expansion",b"volume_expansion"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["service","volume_expansion"]]: ...
global___PluginCapability = PluginCapability

class ProbeRequest(google.protobuf.message.Message):
    """Intentionally empty."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___ProbeRequest = ProbeRequest

class ProbeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    READY_FIELD_NUMBER: builtins.int
    @property
    def ready(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Readiness allows a plugin to report its initialization status back
        to the CO. Initialization for some plugins MAY be time consuming
        and it is important for a CO to distinguish between the following
        cases:

        1) The plugin is in an unhealthy state and MAY need restarting. In
           this case a gRPC error code SHALL be returned.
        2) The plugin is still initializing, but is otherwise perfectly
           healthy. In this case a successful response SHALL be returned
           with a readiness value of `false`. Calls to the plugin's
           Controller and/or Node services MAY fail due to an incomplete
           initialization state.
        3) The plugin has finished initializing and is ready to service
           calls to its Controller and/or Node services. A successful
           response is returned with a readiness value of `true`.

        This field is OPTIONAL. If not present, the caller SHALL assume
        that the plugin is in a ready state and is accepting calls to its
        Controller and/or Node services (according to the plugin's reported
        capabilities).
        """
        pass
    def __init__(self,
        *,
        ready : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["ready",b"ready"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["ready",b"ready"]) -> None: ...
global___ProbeResponse = ProbeResponse

class CreateVolumeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class ParametersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class SecretsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    CAPACITY_RANGE_FIELD_NUMBER: builtins.int
    VOLUME_CAPABILITIES_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    SECRETS_FIELD_NUMBER: builtins.int
    VOLUME_CONTENT_SOURCE_FIELD_NUMBER: builtins.int
    ACCESSIBILITY_REQUIREMENTS_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """The suggested name for the storage space. This field is REQUIRED.
    It serves two purposes:
    1) Idempotency - This name is generated by the CO to achieve
       idempotency.  The Plugin SHOULD ensure that multiple
       `CreateVolume` calls for the same name do not result in more
       than one piece of storage provisioned corresponding to that
       name. If a Plugin is unable to enforce idempotency, the CO's
       error recovery logic could result in multiple (unused) volumes
       being provisioned.
       In the case of error, the CO MUST handle the gRPC error codes
       per the recovery behavior defined in the "CreateVolume Errors"
       section below.
       The CO is responsible for cleaning up volumes it provisioned
       that it no longer needs. If the CO is uncertain whether a volume
       was provisioned or not when a `CreateVolume` call fails, the CO
       MAY call `CreateVolume` again, with the same name, to ensure the
       volume exists and to retrieve the volume's `volume_id` (unless
       otherwise prohibited by "CreateVolume Errors").
    2) Suggested name - Some storage systems allow callers to specify
       an identifier by which to refer to the newly provisioned
       storage. If a storage system supports this, it can optionally
       use this name as the identifier for the new volume.
    Any Unicode string that conforms to the length limit is allowed
    except those containing the following banned characters:
    U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
    (These are control characters other than commonly used whitespace.)
    """

    @property
    def capacity_range(self) -> global___CapacityRange:
        """This field is OPTIONAL. This allows the CO to specify the capacity
        requirement of the volume to be provisioned. If not specified, the
        Plugin MAY choose an implementation-defined capacity range. If
        specified it MUST always be honored, even when creating volumes
        from a source; which MAY force some backends to internally extend
        the volume after creating it.
        """
        pass
    @property
    def volume_capabilities(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___VolumeCapability]:
        """The capabilities that the provisioned volume MUST have. SP MUST
        provision a volume that will satisfy ALL of the capabilities
        specified in this list. Otherwise SP MUST return the appropriate
        gRPC error code.
        The Plugin MUST assume that the CO MAY use the provisioned volume
        with ANY of the capabilities specified in this list.
        For example, a CO MAY specify two volume capabilities: one with
        access mode SINGLE_NODE_WRITER and another with access mode
        MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
        provisioned volume can be used in either mode.
        This also enables the CO to do early validation: If ANY of the
        specified volume capabilities are not supported by the SP, the call
        MUST return the appropriate gRPC error code.
        This field is REQUIRED.
        """
        pass
    @property
    def parameters(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Plugin specific parameters passed in as opaque key-value pairs.
        This field is OPTIONAL. The Plugin is responsible for parsing and
        validating these parameters. COs will treat these as opaque.
        """
        pass
    @property
    def secrets(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Secrets required by plugin to complete volume creation request.
        This field is OPTIONAL. Refer to the `Secrets Requirements`
        section on how to use this field.
        """
        pass
    @property
    def volume_content_source(self) -> global___VolumeContentSource:
        """If specified, the new volume will be pre-populated with data from
        this source. This field is OPTIONAL.
        """
        pass
    @property
    def accessibility_requirements(self) -> global___TopologyRequirement:
        """Specifies where (regions, zones, racks, etc.) the provisioned
        volume MUST be accessible from.
        An SP SHALL advertise the requirements for topological
        accessibility information in documentation. COs SHALL only specify
        topological accessibility information supported by the SP.
        This field is OPTIONAL.
        This field SHALL NOT be specified unless the SP has the
        VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
        If this field is not specified and the SP has the
        VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY
        choose where the provisioned volume is accessible from.
        """
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        capacity_range : typing.Optional[global___CapacityRange] = ...,
        volume_capabilities : typing.Optional[typing.Iterable[global___VolumeCapability]] = ...,
        parameters : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        secrets : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        volume_content_source : typing.Optional[global___VolumeContentSource] = ...,
        accessibility_requirements : typing.Optional[global___TopologyRequirement] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["accessibility_requirements",b"accessibility_requirements","capacity_range",b"capacity_range","volume_content_source",b"volume_content_source"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["accessibility_requirements",b"accessibility_requirements","capacity_range",b"capacity_range","name",b"name","parameters",b"parameters","secrets",b"secrets","volume_capabilities",b"volume_capabilities","volume_content_source",b"volume_content_source"]) -> None: ...
global___CreateVolumeRequest = CreateVolumeRequest

class VolumeContentSource(google.protobuf.message.Message):
    """Specifies what source the volume will be created from. One of the
    type fields MUST be specified.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class SnapshotSource(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        SNAPSHOT_ID_FIELD_NUMBER: builtins.int
        snapshot_id: typing.Text = ...
        """Contains identity information for the existing source snapshot.
        This field is REQUIRED. Plugin is REQUIRED to support creating
        volume from snapshot if it supports the capability
        CREATE_DELETE_SNAPSHOT.
        """

        def __init__(self,
            *,
            snapshot_id : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["snapshot_id",b"snapshot_id"]) -> None: ...

    class VolumeSource(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        VOLUME_ID_FIELD_NUMBER: builtins.int
        volume_id: typing.Text = ...
        """Contains identity information for the existing source volume.
        This field is REQUIRED. Plugins reporting CLONE_VOLUME
        capability MUST support creating a volume from another volume.
        """

        def __init__(self,
            *,
            volume_id : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["volume_id",b"volume_id"]) -> None: ...

    SNAPSHOT_FIELD_NUMBER: builtins.int
    VOLUME_FIELD_NUMBER: builtins.int
    @property
    def snapshot(self) -> global___VolumeContentSource.SnapshotSource: ...
    @property
    def volume(self) -> global___VolumeContentSource.VolumeSource: ...
    def __init__(self,
        *,
        snapshot : typing.Optional[global___VolumeContentSource.SnapshotSource] = ...,
        volume : typing.Optional[global___VolumeContentSource.VolumeSource] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["snapshot",b"snapshot","type",b"type","volume",b"volume"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["snapshot",b"snapshot","type",b"type","volume",b"volume"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["snapshot","volume"]]: ...
global___VolumeContentSource = VolumeContentSource

class CreateVolumeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    VOLUME_FIELD_NUMBER: builtins.int
    @property
    def volume(self) -> global___Volume:
        """Contains all attributes of the newly created volume that are
        relevant to the CO along with information required by the Plugin
        to uniquely identify the volume. This field is REQUIRED.
        """
        pass
    def __init__(self,
        *,
        volume : typing.Optional[global___Volume] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["volume",b"volume"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["volume",b"volume"]) -> None: ...
global___CreateVolumeResponse = CreateVolumeResponse

class VolumeCapability(google.protobuf.message.Message):
    """Specify a capability of a volume."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class BlockVolume(google.protobuf.message.Message):
        """Indicate that the volume will be accessed via the block device API.
        Intentionally empty, for now.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        def __init__(self,
            ) -> None: ...

    class MountVolume(google.protobuf.message.Message):
        """Indicate that the volume will be accessed via the filesystem API."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        FS_TYPE_FIELD_NUMBER: builtins.int
        MOUNT_FLAGS_FIELD_NUMBER: builtins.int
        VOLUME_MOUNT_GROUP_FIELD_NUMBER: builtins.int
        fs_type: typing.Text = ...
        """The filesystem type. This field is OPTIONAL.
        An empty string is equal to an unspecified field value.
        """

        @property
        def mount_flags(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """The mount options that can be used for the volume. This field is
            OPTIONAL. `mount_flags` MAY contain sensitive information.
            Therefore, the CO and the Plugin MUST NOT leak this information
            to untrusted entities. The total size of this repeated field
            SHALL NOT exceed 4 KiB.
            """
            pass
        volume_mount_group: typing.Text = ...
        """If SP has VOLUME_MOUNT_GROUP node capability and CO provides
        this field then SP MUST ensure that the volume_mount_group
        parameter is passed as the group identifier to the underlying
        operating system mount system call, with the understanding
        that the set of available mount call parameters and/or
        mount implementations may vary across operating systems.
        Additionally, new file and/or directory entries written to
        the underlying filesystem SHOULD be permission-labeled in such a
        manner, unless otherwise modified by a workload, that they are
        both readable and writable by said mount group identifier.
        This is an OPTIONAL field.
        """

        def __init__(self,
            *,
            fs_type : typing.Text = ...,
            mount_flags : typing.Optional[typing.Iterable[typing.Text]] = ...,
            volume_mount_group : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["fs_type",b"fs_type","mount_flags",b"mount_flags","volume_mount_group",b"volume_mount_group"]) -> None: ...

    class AccessMode(google.protobuf.message.Message):
        """Specify how a volume can be accessed."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class Mode(_Mode, metaclass=_ModeEnumTypeWrapper):
            pass
        class _Mode:
            V = typing.NewType('V', builtins.int)
        class _ModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Mode.V], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
            UNKNOWN = VolumeCapability.AccessMode.Mode.V(0)
            SINGLE_NODE_WRITER = VolumeCapability.AccessMode.Mode.V(1)
            """Can only be published once as read/write on a single node, at
            any given time.
            """

            SINGLE_NODE_READER_ONLY = VolumeCapability.AccessMode.Mode.V(2)
            """Can only be published once as readonly on a single node, at
            any given time.
            """

            MULTI_NODE_READER_ONLY = VolumeCapability.AccessMode.Mode.V(3)
            """Can be published as readonly at multiple nodes simultaneously."""

            MULTI_NODE_SINGLE_WRITER = VolumeCapability.AccessMode.Mode.V(4)
            """Can be published at multiple nodes simultaneously. Only one of
            the node can be used as read/write. The rest will be readonly.
            """

            MULTI_NODE_MULTI_WRITER = VolumeCapability.AccessMode.Mode.V(5)
            """Can be published as read/write at multiple nodes
            simultaneously.
            """

            SINGLE_NODE_SINGLE_WRITER = VolumeCapability.AccessMode.Mode.V(6)
            """Can only be published once as read/write at a single workload
            on a single node, at any given time. SHOULD be used instead of
            SINGLE_NODE_WRITER for COs using the experimental
            SINGLE_NODE_MULTI_WRITER capability.
            """

            SINGLE_NODE_MULTI_WRITER = VolumeCapability.AccessMode.Mode.V(7)
            """Can be published as read/write at multiple workloads on a
            single node simultaneously. SHOULD be used instead of
            SINGLE_NODE_WRITER for COs using the experimental
            SINGLE_NODE_MULTI_WRITER capability.
            """


        UNKNOWN = VolumeCapability.AccessMode.Mode.V(0)
        SINGLE_NODE_WRITER = VolumeCapability.AccessMode.Mode.V(1)
        """Can only be published once as read/write on a single node, at
        any given time.
        """

        SINGLE_NODE_READER_ONLY = VolumeCapability.AccessMode.Mode.V(2)
        """Can only be published once as readonly on a single node, at
        any given time.
        """

        MULTI_NODE_READER_ONLY = VolumeCapability.AccessMode.Mode.V(3)
        """Can be published as readonly at multiple nodes simultaneously."""

        MULTI_NODE_SINGLE_WRITER = VolumeCapability.AccessMode.Mode.V(4)
        """Can be published at multiple nodes simultaneously. Only one of
        the node can be used as read/write. The rest will be readonly.
        """

        MULTI_NODE_MULTI_WRITER = VolumeCapability.AccessMode.Mode.V(5)
        """Can be published as read/write at multiple nodes
        simultaneously.
        """

        SINGLE_NODE_SINGLE_WRITER = VolumeCapability.AccessMode.Mode.V(6)
        """Can only be published once as read/write at a single workload
        on a single node, at any given time. SHOULD be used instead of
        SINGLE_NODE_WRITER for COs using the experimental
        SINGLE_NODE_MULTI_WRITER capability.
        """

        SINGLE_NODE_MULTI_WRITER = VolumeCapability.AccessMode.Mode.V(7)
        """Can be published as read/write at multiple workloads on a
        single node simultaneously. SHOULD be used instead of
        SINGLE_NODE_WRITER for COs using the experimental
        SINGLE_NODE_MULTI_WRITER capability.
        """


        MODE_FIELD_NUMBER: builtins.int
        mode: global___VolumeCapability.AccessMode.Mode.V = ...
        """This field is REQUIRED."""

        def __init__(self,
            *,
            mode : global___VolumeCapability.AccessMode.Mode.V = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["mode",b"mode"]) -> None: ...

    BLOCK_FIELD_NUMBER: builtins.int
    MOUNT_FIELD_NUMBER: builtins.int
    ACCESS_MODE_FIELD_NUMBER: builtins.int
    @property
    def block(self) -> global___VolumeCapability.BlockVolume: ...
    @property
    def mount(self) -> global___VolumeCapability.MountVolume: ...
    @property
    def access_mode(self) -> global___VolumeCapability.AccessMode:
        """This is a REQUIRED field."""
        pass
    def __init__(self,
        *,
        block : typing.Optional[global___VolumeCapability.BlockVolume] = ...,
        mount : typing.Optional[global___VolumeCapability.MountVolume] = ...,
        access_mode : typing.Optional[global___VolumeCapability.AccessMode] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["access_mode",b"access_mode","access_type",b"access_type","block",b"block","mount",b"mount"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["access_mode",b"access_mode","access_type",b"access_type","block",b"block","mount",b"mount"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["access_type",b"access_type"]) -> typing.Optional[typing_extensions.Literal["block","mount"]]: ...
global___VolumeCapability = VolumeCapability

class CapacityRange(google.protobuf.message.Message):
    """The capacity of the storage space in bytes. To specify an exact size,
    `required_bytes` and `limit_bytes` SHALL be set to the same value. At
    least one of the these fields MUST be specified.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    REQUIRED_BYTES_FIELD_NUMBER: builtins.int
    LIMIT_BYTES_FIELD_NUMBER: builtins.int
    required_bytes: builtins.int = ...
    """Volume MUST be at least this big. This field is OPTIONAL.
    A value of 0 is equal to an unspecified field value.
    The value of this field MUST NOT be negative.
    """

    limit_bytes: builtins.int = ...
    """Volume MUST not be bigger than this. This field is OPTIONAL.
    A value of 0 is equal to an unspecified field value.
    The value of this field MUST NOT be negative.
    """

    def __init__(self,
        *,
        required_bytes : builtins.int = ...,
        limit_bytes : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["limit_bytes",b"limit_bytes","required_bytes",b"required_bytes"]) -> None: ...
global___CapacityRange = CapacityRange

class Volume(google.protobuf.message.Message):
    """Information about a specific volume."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class VolumeContextEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    CAPACITY_BYTES_FIELD_NUMBER: builtins.int
    VOLUME_ID_FIELD_NUMBER: builtins.int
    VOLUME_CONTEXT_FIELD_NUMBER: builtins.int
    CONTENT_SOURCE_FIELD_NUMBER: builtins.int
    ACCESSIBLE_TOPOLOGY_FIELD_NUMBER: builtins.int
    capacity_bytes: builtins.int = ...
    """The capacity of the volume in bytes. This field is OPTIONAL. If not
    set (value of 0), it indicates that the capacity of the volume is
    unknown (e.g., NFS share).
    The value of this field MUST NOT be negative.
    """

    volume_id: typing.Text = ...
    """The identifier for this volume, generated by the plugin.
    This field is REQUIRED.
    This field MUST contain enough information to uniquely identify
    this specific volume vs all other volumes supported by this plugin.
    This field SHALL be used by the CO in subsequent calls to refer to
    this volume.
    The SP is NOT responsible for global uniqueness of volume_id across
    multiple SPs.
    """

    @property
    def volume_context(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Opaque static properties of the volume. SP MAY use this field to
        ensure subsequent volume validation and publishing calls have
        contextual information.
        The contents of this field SHALL be opaque to a CO.
        The contents of this field SHALL NOT be mutable.
        The contents of this field SHALL be safe for the CO to cache.
        The contents of this field SHOULD NOT contain sensitive
        information.
        The contents of this field SHOULD NOT be used for uniquely
        identifying a volume. The `volume_id` alone SHOULD be sufficient to
        identify the volume.
        A volume uniquely identified by `volume_id` SHALL always report the
        same volume_context.
        This field is OPTIONAL and when present MUST be passed to volume
        validation and publishing calls.
        """
        pass
    @property
    def content_source(self) -> global___VolumeContentSource:
        """If specified, indicates that the volume is not empty and is
        pre-populated with data from the specified source.
        This field is OPTIONAL.
        """
        pass
    @property
    def accessible_topology(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Topology]:
        """Specifies where (regions, zones, racks, etc.) the provisioned
        volume is accessible from.
        A plugin that returns this field MUST also set the
        VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
        An SP MAY specify multiple topologies to indicate the volume is
        accessible from multiple locations.
        COs MAY use this information along with the topology information
        returned by NodeGetInfo to ensure that a given volume is accessible
        from a given node when scheduling workloads.
        This field is OPTIONAL. If it is not specified, the CO MAY assume
        the volume is equally accessible from all nodes in the cluster and
        MAY schedule workloads referencing the volume on any available
        node.

        Example 1:
          accessible_topology = {"region": "R1", "zone": "Z2"}
        Indicates a volume accessible only from the "region" "R1" and the
        "zone" "Z2".

        Example 2:
          accessible_topology =
            {"region": "R1", "zone": "Z2"},
            {"region": "R1", "zone": "Z3"}
        Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
        in the "region" "R1".
        """
        pass
    def __init__(self,
        *,
        capacity_bytes : builtins.int = ...,
        volume_id : typing.Text = ...,
        volume_context : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        content_source : typing.Optional[global___VolumeContentSource] = ...,
        accessible_topology : typing.Optional[typing.Iterable[global___Topology]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["content_source",b"content_source"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["accessible_topology",b"accessible_topology","capacity_bytes",b"capacity_bytes","content_source",b"content_source","volume_context",b"volume_context","volume_id",b"volume_id"]) -> None: ...
global___Volume = Volume

class TopologyRequirement(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    REQUISITE_FIELD_NUMBER: builtins.int
    PREFERRED_FIELD_NUMBER: builtins.int
    @property
    def requisite(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Topology]:
        """Specifies the list of topologies the provisioned volume MUST be
        accessible from.
        This field is OPTIONAL. If TopologyRequirement is specified either
        requisite or preferred or both MUST be specified.

        If requisite is specified, the provisioned volume MUST be
        accessible from at least one of the requisite topologies.

        Given
          x = number of topologies provisioned volume is accessible from
          n = number of requisite topologies
        The CO MUST ensure n >= 1. The SP MUST ensure x >= 1
        If x==n, then the SP MUST make the provisioned volume available to
        all topologies from the list of requisite topologies. If it is
        unable to do so, the SP MUST fail the CreateVolume call.
        For example, if a volume should be accessible from a single zone,
        and requisite =
          {"region": "R1", "zone": "Z2"}
        then the provisioned volume MUST be accessible from the "region"
        "R1" and the "zone" "Z2".
        Similarly, if a volume should be accessible from two zones, and
        requisite =
          {"region": "R1", "zone": "Z2"},
          {"region": "R1", "zone": "Z3"}
        then the provisioned volume MUST be accessible from the "region"
        "R1" and both "zone" "Z2" and "zone" "Z3".

        If x<n, then the SP SHALL choose x unique topologies from the list
        of requisite topologies. If it is unable to do so, the SP MUST fail
        the CreateVolume call.
        For example, if a volume should be accessible from a single zone,
        and requisite =
          {"region": "R1", "zone": "Z2"},
          {"region": "R1", "zone": "Z3"}
        then the SP may choose to make the provisioned volume available in
        either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
        Similarly, if a volume should be accessible from two zones, and
        requisite =
          {"region": "R1", "zone": "Z2"},
          {"region": "R1", "zone": "Z3"},
          {"region": "R1", "zone": "Z4"}
        then the provisioned volume MUST be accessible from any combination
        of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
         "R1/Z4", or "R1/Z3" and "R1/Z4".

        If x>n, then the SP MUST make the provisioned volume available from
        all topologies from the list of requisite topologies and MAY choose
        the remaining x-n unique topologies from the list of all possible
        topologies. If it is unable to do so, the SP MUST fail the
        CreateVolume call.
        For example, if a volume should be accessible from two zones, and
        requisite =
          {"region": "R1", "zone": "Z2"}
        then the provisioned volume MUST be accessible from the "region"
        "R1" and the "zone" "Z2" and the SP may select the second zone
        independently, e.g. "R1/Z4".
        """
        pass
    @property
    def preferred(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Topology]:
        """Specifies the list of topologies the CO would prefer the volume to
        be provisioned in.

        This field is OPTIONAL. If TopologyRequirement is specified either
        requisite or preferred or both MUST be specified.

        An SP MUST attempt to make the provisioned volume available using
        the preferred topologies in order from first to last.

        If requisite is specified, all topologies in preferred list MUST
        also be present in the list of requisite topologies.

        If the SP is unable to to make the provisioned volume available
        from any of the preferred topologies, the SP MAY choose a topology
        from the list of requisite topologies.
        If the list of requisite topologies is not specified, then the SP
        MAY choose from the list of all possible topologies.
        If the list of requisite topologies is specified and the SP is
        unable to to make the provisioned volume available from any of the
        requisite topologies it MUST fail the CreateVolume call.

        Example 1:
        Given a volume should be accessible from a single zone, and
        requisite =
          {"region": "R1", "zone": "Z2"},
          {"region": "R1", "zone": "Z3"}
        preferred =
          {"region": "R1", "zone": "Z3"}
        then the the SP SHOULD first attempt to make the provisioned volume
        available from "zone" "Z3" in the "region" "R1" and fall back to
        "zone" "Z2" in the "region" "R1" if that is not possible.

        Example 2:
        Given a volume should be accessible from a single zone, and
        requisite =
          {"region": "R1", "zone": "Z2"},
          {"region": "R1", "zone": "Z3"},
          {"region": "R1", "zone": "Z4"},
          {"region": "R1", "zone": "Z5"}
        preferred =
          {"region": "R1", "zone": "Z4"},
          {"region": "R1", "zone": "Z2"}
        then the the SP SHOULD first attempt to make the provisioned volume
        accessible from "zone" "Z4" in the "region" "R1" and fall back to
        "zone" "Z2" in the "region" "R1" if that is not possible. If that
        is not possible, the SP may choose between either the "zone"
        "Z3" or "Z5" in the "region" "R1".

        Example 3:
        Given a volume should be accessible from TWO zones (because an
        opaque parameter in CreateVolumeRequest, for example, specifies
        the volume is accessible from two zones, aka synchronously
        replicated), and
        requisite =
          {"region": "R1", "zone": "Z2"},
          {"region": "R1", "zone": "Z3"},
          {"region": "R1", "zone": "Z4"},
          {"region": "R1", "zone": "Z5"}
        preferred =
          {"region": "R1", "zone": "Z5"},
          {"region": "R1", "zone": "Z3"}
        then the the SP SHOULD first attempt to make the provisioned volume
        accessible from the combination of the two "zones" "Z5" and "Z3" in
        the "region" "R1". If that's not possible, it should fall back to
        a combination of "Z5" and other possibilities from the list of
        requisite. If that's not possible, it should fall back  to a
        combination of "Z3" and other possibilities from the list of
        requisite. If that's not possible, it should fall back  to a
        combination of other possibilities from the list of requisite.
        """
        pass
    def __init__(self,
        *,
        requisite : typing.Optional[typing.Iterable[global___Topology]] = ...,
        preferred : typing.Optional[typing.Iterable[global___Topology]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["preferred",b"preferred","requisite",b"requisite"]) -> None: ...
global___TopologyRequirement = TopologyRequirement

class Topology(google.protobuf.message.Message):
    """Topology is a map of topological domains to topological segments.
    A topological domain is a sub-division of a cluster, like "region",
    "zone", "rack", etc.
    A topological segment is a specific instance of a topological domain,
    like "zone3", "rack3", etc.
    For example {"com.company/zone": "Z1", "com.company/rack": "R3"}
    Valid keys have two segments: an OPTIONAL prefix and name, separated
    by a slash (/), for example: "com.company.example/zone".
    The key name segment is REQUIRED. The prefix is OPTIONAL.
    The key name MUST be 63 characters or less, begin and end with an
    alphanumeric character ([a-z0-9A-Z]), and contain only dashes (-),
    underscores (_), dots (.), or alphanumerics in between, for example
    "zone".
    The key prefix MUST be 63 characters or less, begin and end with a
    lower-case alphanumeric character ([a-z0-9]), contain only
    dashes (-), dots (.), or lower-case alphanumerics in between, and
    follow domain name notation format
    (https://tools.ietf.org/html/rfc1035#section-2.3.1).
    The key prefix SHOULD include the plugin's host company name and/or
    the plugin name, to minimize the possibility of collisions with keys
    from other plugins.
    If a key prefix is specified, it MUST be identical across all
    topology keys returned by the SP (across all RPCs).
    Keys MUST be case-insensitive. Meaning the keys "Zone" and "zone"
    MUST not both exist.
    Each value (topological segment) MUST contain 1 or more strings.
    Each string MUST be 63 characters or less and begin and end with an
    alphanumeric character with '-', '_', '.', or alphanumerics in
    between.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class SegmentsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    SEGMENTS_FIELD_NUMBER: builtins.int
    @property
    def segments(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]: ...
    def __init__(self,
        *,
        segments : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["segments",b"segments"]) -> None: ...
global___Topology = Topology

class DeleteVolumeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class SecretsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    VOLUME_ID_FIELD_NUMBER: builtins.int
    SECRETS_FIELD_NUMBER: builtins.int
    volume_id: typing.Text = ...
    """The ID of the volume to be deprovisioned.
    This field is REQUIRED.
    """

    @property
    def secrets(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Secrets required by plugin to complete volume deletion request.
        This field is OPTIONAL. Refer to the `Secrets Requirements`
        section on how to use this field.
        """
        pass
    def __init__(self,
        *,
        volume_id : typing.Text = ...,
        secrets : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["secrets",b"secrets","volume_id",b"volume_id"]) -> None: ...
global___DeleteVolumeRequest = DeleteVolumeRequest

class DeleteVolumeResponse(google.protobuf.message.Message):
    """Intentionally empty."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___DeleteVolumeResponse = DeleteVolumeResponse

class ControllerPublishVolumeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class SecretsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class VolumeContextEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    VOLUME_ID_FIELD_NUMBER: builtins.int
    NODE_ID_FIELD_NUMBER: builtins.int
    VOLUME_CAPABILITY_FIELD_NUMBER: builtins.int
    READONLY_FIELD_NUMBER: builtins.int
    SECRETS_FIELD_NUMBER: builtins.int
    VOLUME_CONTEXT_FIELD_NUMBER: builtins.int
    volume_id: typing.Text = ...
    """The ID of the volume to be used on a node.
    This field is REQUIRED.
    """

    node_id: typing.Text = ...
    """The ID of the node. This field is REQUIRED. The CO SHALL set this
    field to match the node ID returned by `NodeGetInfo`.
    """

    @property
    def volume_capability(self) -> global___VolumeCapability:
        """Volume capability describing how the CO intends to use this volume.
        SP MUST ensure the CO can use the published volume as described.
        Otherwise SP MUST return the appropriate gRPC error code.
        This is a REQUIRED field.
        """
        pass
    readonly: builtins.bool = ...
    """Indicates SP MUST publish the volume in readonly mode.
    CO MUST set this field to false if SP does not have the
    PUBLISH_READONLY controller capability.
    This is a REQUIRED field.
    """

    @property
    def secrets(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Secrets required by plugin to complete controller publish volume
        request. This field is OPTIONAL. Refer to the
        `Secrets Requirements` section on how to use this field.
        """
        pass
    @property
    def volume_context(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Volume context as returned by SP in
        CreateVolumeResponse.Volume.volume_context.
        This field is OPTIONAL and MUST match the volume_context of the
        volume identified by `volume_id`.
        """
        pass
    def __init__(self,
        *,
        volume_id : typing.Text = ...,
        node_id : typing.Text = ...,
        volume_capability : typing.Optional[global___VolumeCapability] = ...,
        readonly : builtins.bool = ...,
        secrets : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        volume_context : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["volume_capability",b"volume_capability"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["node_id",b"node_id","readonly",b"readonly","secrets",b"secrets","volume_capability",b"volume_capability","volume_context",b"volume_context","volume_id",b"volume_id"]) -> None: ...
global___ControllerPublishVolumeRequest = ControllerPublishVolumeRequest

class ControllerPublishVolumeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class PublishContextEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    PUBLISH_CONTEXT_FIELD_NUMBER: builtins.int
    @property
    def publish_context(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Opaque static publish properties of the volume. SP MAY use this
        field to ensure subsequent `NodeStageVolume` or `NodePublishVolume`
        calls calls have contextual information.
        The contents of this field SHALL be opaque to a CO.
        The contents of this field SHALL NOT be mutable.
        The contents of this field SHALL be safe for the CO to cache.
        The contents of this field SHOULD NOT contain sensitive
        information.
        The contents of this field SHOULD NOT be used for uniquely
        identifying a volume. The `volume_id` alone SHOULD be sufficient to
        identify the volume.
        This field is OPTIONAL and when present MUST be passed to
        subsequent `NodeStageVolume` or `NodePublishVolume` calls
        """
        pass
    def __init__(self,
        *,
        publish_context : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["publish_context",b"publish_context"]) -> None: ...
global___ControllerPublishVolumeResponse = ControllerPublishVolumeResponse

class ControllerUnpublishVolumeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class SecretsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    VOLUME_ID_FIELD_NUMBER: builtins.int
    NODE_ID_FIELD_NUMBER: builtins.int
    SECRETS_FIELD_NUMBER: builtins.int
    volume_id: typing.Text = ...
    """The ID of the volume. This field is REQUIRED."""

    node_id: typing.Text = ...
    """The ID of the node. This field is OPTIONAL. The CO SHOULD set this
    field to match the node ID returned by `NodeGetInfo` or leave it
    unset. If the value is set, the SP MUST unpublish the volume from
    the specified node. If the value is unset, the SP MUST unpublish
    the volume from all nodes it is published to.
    """

    @property
    def secrets(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Secrets required by plugin to complete controller unpublish volume
        request. This SHOULD be the same secrets passed to the
        ControllerPublishVolume call for the specified volume.
        This field is OPTIONAL. Refer to the `Secrets Requirements`
        section on how to use this field.
        """
        pass
    def __init__(self,
        *,
        volume_id : typing.Text = ...,
        node_id : typing.Text = ...,
        secrets : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["node_id",b"node_id","secrets",b"secrets","volume_id",b"volume_id"]) -> None: ...
global___ControllerUnpublishVolumeRequest = ControllerUnpublishVolumeRequest

class ControllerUnpublishVolumeResponse(google.protobuf.message.Message):
    """Intentionally empty."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___ControllerUnpublishVolumeResponse = ControllerUnpublishVolumeResponse

class ValidateVolumeCapabilitiesRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class VolumeContextEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class ParametersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class SecretsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    VOLUME_ID_FIELD_NUMBER: builtins.int
    VOLUME_CONTEXT_FIELD_NUMBER: builtins.int
    VOLUME_CAPABILITIES_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    SECRETS_FIELD_NUMBER: builtins.int
    volume_id: typing.Text = ...
    """The ID of the volume to check. This field is REQUIRED."""

    @property
    def volume_context(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Volume context as returned by SP in
        CreateVolumeResponse.Volume.volume_context.
        This field is OPTIONAL and MUST match the volume_context of the
        volume identified by `volume_id`.
        """
        pass
    @property
    def volume_capabilities(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___VolumeCapability]:
        """The capabilities that the CO wants to check for the volume. This
        call SHALL return "confirmed" only if all the volume capabilities
        specified below are supported. This field is REQUIRED.
        """
        pass
    @property
    def parameters(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """See CreateVolumeRequest.parameters.
        This field is OPTIONAL.
        """
        pass
    @property
    def secrets(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Secrets required by plugin to complete volume validation request.
        This field is OPTIONAL. Refer to the `Secrets Requirements`
        section on how to use this field.
        """
        pass
    def __init__(self,
        *,
        volume_id : typing.Text = ...,
        volume_context : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        volume_capabilities : typing.Optional[typing.Iterable[global___VolumeCapability]] = ...,
        parameters : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        secrets : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["parameters",b"parameters","secrets",b"secrets","volume_capabilities",b"volume_capabilities","volume_context",b"volume_context","volume_id",b"volume_id"]) -> None: ...
global___ValidateVolumeCapabilitiesRequest = ValidateVolumeCapabilitiesRequest

class ValidateVolumeCapabilitiesResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Confirmed(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class VolumeContextEntry(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            KEY_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            key: typing.Text = ...
            value: typing.Text = ...
            def __init__(self,
                *,
                key : typing.Text = ...,
                value : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

        class ParametersEntry(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            KEY_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            key: typing.Text = ...
            value: typing.Text = ...
            def __init__(self,
                *,
                key : typing.Text = ...,
                value : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

        VOLUME_CONTEXT_FIELD_NUMBER: builtins.int
        VOLUME_CAPABILITIES_FIELD_NUMBER: builtins.int
        PARAMETERS_FIELD_NUMBER: builtins.int
        @property
        def volume_context(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
            """Volume context validated by the plugin.
            This field is OPTIONAL.
            """
            pass
        @property
        def volume_capabilities(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___VolumeCapability]:
            """Volume capabilities supported by the plugin.
            This field is REQUIRED.
            """
            pass
        @property
        def parameters(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
            """The volume creation parameters validated by the plugin.
            This field is OPTIONAL.
            """
            pass
        def __init__(self,
            *,
            volume_context : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
            volume_capabilities : typing.Optional[typing.Iterable[global___VolumeCapability]] = ...,
            parameters : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["parameters",b"parameters","volume_capabilities",b"volume_capabilities","volume_context",b"volume_context"]) -> None: ...

    CONFIRMED_FIELD_NUMBER: builtins.int
    MESSAGE_FIELD_NUMBER: builtins.int
    @property
    def confirmed(self) -> global___ValidateVolumeCapabilitiesResponse.Confirmed:
        """Confirmed indicates to the CO the set of capabilities that the
        plugin has validated. This field SHALL only be set to a non-empty
        value for successful validation responses.
        For successful validation responses, the CO SHALL compare the
        fields of this message to the originally requested capabilities in
        order to guard against an older plugin reporting "valid" for newer
        capability fields that it does not yet understand.
        This field is OPTIONAL.
        """
        pass
    message: typing.Text = ...
    """Message to the CO if `confirmed` above is empty. This field is
    OPTIONAL.
    An empty string is equal to an unspecified field value.
    """

    def __init__(self,
        *,
        confirmed : typing.Optional[global___ValidateVolumeCapabilitiesResponse.Confirmed] = ...,
        message : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["confirmed",b"confirmed"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["confirmed",b"confirmed","message",b"message"]) -> None: ...
global___ValidateVolumeCapabilitiesResponse = ValidateVolumeCapabilitiesResponse

class ListVolumesRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    MAX_ENTRIES_FIELD_NUMBER: builtins.int
    STARTING_TOKEN_FIELD_NUMBER: builtins.int
    max_entries: builtins.int = ...
    """If specified (non-zero value), the Plugin MUST NOT return more
    entries than this number in the response. If the actual number of
    entries is more than this number, the Plugin MUST set `next_token`
    in the response which can be used to get the next page of entries
    in the subsequent `ListVolumes` call. This field is OPTIONAL. If
    not specified (zero value), it means there is no restriction on the
    number of entries that can be returned.
    The value of this field MUST NOT be negative.
    """

    starting_token: typing.Text = ...
    """A token to specify where to start paginating. Set this field to
    `next_token` returned by a previous `ListVolumes` call to get the
    next page of entries. This field is OPTIONAL.
    An empty string is equal to an unspecified field value.
    """

    def __init__(self,
        *,
        max_entries : builtins.int = ...,
        starting_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["max_entries",b"max_entries","starting_token",b"starting_token"]) -> None: ...
global___ListVolumesRequest = ListVolumesRequest

class ListVolumesResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class VolumeStatus(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        PUBLISHED_NODE_IDS_FIELD_NUMBER: builtins.int
        VOLUME_CONDITION_FIELD_NUMBER: builtins.int
        @property
        def published_node_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """A list of all `node_id` of nodes that the volume in this entry
            is controller published on.
            This field is OPTIONAL. If it is not specified and the SP has
            the LIST_VOLUMES_PUBLISHED_NODES controller capability, the CO
            MAY assume the volume is not controller published to any nodes.
            If the field is not specified and the SP does not have the
            LIST_VOLUMES_PUBLISHED_NODES controller capability, the CO MUST
            not interpret this field.
            published_node_ids MAY include nodes not published to or
            reported by the SP. The CO MUST be resilient to that.
            """
            pass
        @property
        def volume_condition(self) -> global___VolumeCondition:
            """Information about the current condition of the volume.
            This field is OPTIONAL.
            This field MUST be specified if the
            VOLUME_CONDITION controller capability is supported.
            """
            pass
        def __init__(self,
            *,
            published_node_ids : typing.Optional[typing.Iterable[typing.Text]] = ...,
            volume_condition : typing.Optional[global___VolumeCondition] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["volume_condition",b"volume_condition"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["published_node_ids",b"published_node_ids","volume_condition",b"volume_condition"]) -> None: ...

    class Entry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        VOLUME_FIELD_NUMBER: builtins.int
        STATUS_FIELD_NUMBER: builtins.int
        @property
        def volume(self) -> global___Volume:
            """This field is REQUIRED"""
            pass
        @property
        def status(self) -> global___ListVolumesResponse.VolumeStatus:
            """This field is OPTIONAL. This field MUST be specified if the
            LIST_VOLUMES_PUBLISHED_NODES controller capability is
            supported.
            """
            pass
        def __init__(self,
            *,
            volume : typing.Optional[global___Volume] = ...,
            status : typing.Optional[global___ListVolumesResponse.VolumeStatus] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["status",b"status","volume",b"volume"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["status",b"status","volume",b"volume"]) -> None: ...

    ENTRIES_FIELD_NUMBER: builtins.int
    NEXT_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def entries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ListVolumesResponse.Entry]: ...
    next_token: typing.Text = ...
    """This token allows you to get the next page of entries for
    `ListVolumes` request. If the number of entries is larger than
    `max_entries`, use the `next_token` as a value for the
    `starting_token` field in the next `ListVolumes` request. This
    field is OPTIONAL.
    An empty string is equal to an unspecified field value.
    """

    def __init__(self,
        *,
        entries : typing.Optional[typing.Iterable[global___ListVolumesResponse.Entry]] = ...,
        next_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["entries",b"entries","next_token",b"next_token"]) -> None: ...
global___ListVolumesResponse = ListVolumesResponse

class ControllerGetVolumeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    VOLUME_ID_FIELD_NUMBER: builtins.int
    volume_id: typing.Text = ...
    """The ID of the volume to fetch current volume information for.
    This field is REQUIRED.
    """

    def __init__(self,
        *,
        volume_id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["volume_id",b"volume_id"]) -> None: ...
global___ControllerGetVolumeRequest = ControllerGetVolumeRequest

class ControllerGetVolumeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class VolumeStatus(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        PUBLISHED_NODE_IDS_FIELD_NUMBER: builtins.int
        VOLUME_CONDITION_FIELD_NUMBER: builtins.int
        @property
        def published_node_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """A list of all the `node_id` of nodes that this volume is
            controller published on.
            This field is OPTIONAL.
            This field MUST be specified if the PUBLISH_UNPUBLISH_VOLUME
            controller capability is supported.
            published_node_ids MAY include nodes not published to or
            reported by the SP. The CO MUST be resilient to that.
            """
            pass
        @property
        def volume_condition(self) -> global___VolumeCondition:
            """Information about the current condition of the volume.
            This field is OPTIONAL.
            This field MUST be specified if the
            VOLUME_CONDITION controller capability is supported.
            """
            pass
        def __init__(self,
            *,
            published_node_ids : typing.Optional[typing.Iterable[typing.Text]] = ...,
            volume_condition : typing.Optional[global___VolumeCondition] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["volume_condition",b"volume_condition"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["published_node_ids",b"published_node_ids","volume_condition",b"volume_condition"]) -> None: ...

    VOLUME_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    @property
    def volume(self) -> global___Volume:
        """This field is REQUIRED"""
        pass
    @property
    def status(self) -> global___ControllerGetVolumeResponse.VolumeStatus:
        """This field is REQUIRED."""
        pass
    def __init__(self,
        *,
        volume : typing.Optional[global___Volume] = ...,
        status : typing.Optional[global___ControllerGetVolumeResponse.VolumeStatus] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["status",b"status","volume",b"volume"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["status",b"status","volume",b"volume"]) -> None: ...
global___ControllerGetVolumeResponse = ControllerGetVolumeResponse

class GetCapacityRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class ParametersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    VOLUME_CAPABILITIES_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    ACCESSIBLE_TOPOLOGY_FIELD_NUMBER: builtins.int
    @property
    def volume_capabilities(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___VolumeCapability]:
        """If specified, the Plugin SHALL report the capacity of the storage
        that can be used to provision volumes that satisfy ALL of the
        specified `volume_capabilities`. These are the same
        `volume_capabilities` the CO will use in `CreateVolumeRequest`.
        This field is OPTIONAL.
        """
        pass
    @property
    def parameters(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """If specified, the Plugin SHALL report the capacity of the storage
        that can be used to provision volumes with the given Plugin
        specific `parameters`. These are the same `parameters` the CO will
        use in `CreateVolumeRequest`. This field is OPTIONAL.
        """
        pass
    @property
    def accessible_topology(self) -> global___Topology:
        """If specified, the Plugin SHALL report the capacity of the storage
        that can be used to provision volumes that in the specified
        `accessible_topology`. This is the same as the
        `accessible_topology` the CO returns in a `CreateVolumeResponse`.
        This field is OPTIONAL. This field SHALL NOT be set unless the
        plugin advertises the VOLUME_ACCESSIBILITY_CONSTRAINTS capability.
        """
        pass
    def __init__(self,
        *,
        volume_capabilities : typing.Optional[typing.Iterable[global___VolumeCapability]] = ...,
        parameters : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        accessible_topology : typing.Optional[global___Topology] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["accessible_topology",b"accessible_topology"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["accessible_topology",b"accessible_topology","parameters",b"parameters","volume_capabilities",b"volume_capabilities"]) -> None: ...
global___GetCapacityRequest = GetCapacityRequest

class GetCapacityResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    AVAILABLE_CAPACITY_FIELD_NUMBER: builtins.int
    MAXIMUM_VOLUME_SIZE_FIELD_NUMBER: builtins.int
    MINIMUM_VOLUME_SIZE_FIELD_NUMBER: builtins.int
    available_capacity: builtins.int = ...
    """The available capacity, in bytes, of the storage that can be used
    to provision volumes. If `volume_capabilities` or `parameters` is
    specified in the request, the Plugin SHALL take those into
    consideration when calculating the available capacity of the
    storage. This field is REQUIRED.
    The value of this field MUST NOT be negative.
    """

    @property
    def maximum_volume_size(self) -> google.protobuf.wrappers_pb2.Int64Value:
        """The largest size that may be used in a
        CreateVolumeRequest.capacity_range.required_bytes field
        to create a volume with the same parameters as those in
        GetCapacityRequest.

        If `volume_capabilities` or `parameters` is
        specified in the request, the Plugin SHALL take those into
        consideration when calculating the minimum volume size of the
        storage.

        This field is OPTIONAL. MUST NOT be negative.
        The Plugin SHOULD provide a value for this field if it has
        a maximum size for individual volumes and leave it unset
        otherwise. COs MAY use it to make decision about
        where to create volumes.
        """
        pass
    @property
    def minimum_volume_size(self) -> google.protobuf.wrappers_pb2.Int64Value:
        """The smallest size that may be used in a
        CreateVolumeRequest.capacity_range.limit_bytes field
        to create a volume with the same parameters as those in
        GetCapacityRequest.

        If `volume_capabilities` or `parameters` is
        specified in the request, the Plugin SHALL take those into
        consideration when calculating the maximum volume size of the
        storage.

        This field is OPTIONAL. MUST NOT be negative.
        The Plugin SHOULD provide a value for this field if it has
        a minimum size for individual volumes and leave it unset
        otherwise. COs MAY use it to make decision about
        where to create volumes.
        """
        pass
    def __init__(self,
        *,
        available_capacity : builtins.int = ...,
        maximum_volume_size : typing.Optional[google.protobuf.wrappers_pb2.Int64Value] = ...,
        minimum_volume_size : typing.Optional[google.protobuf.wrappers_pb2.Int64Value] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["maximum_volume_size",b"maximum_volume_size","minimum_volume_size",b"minimum_volume_size"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["available_capacity",b"available_capacity","maximum_volume_size",b"maximum_volume_size","minimum_volume_size",b"minimum_volume_size"]) -> None: ...
global___GetCapacityResponse = GetCapacityResponse

class ControllerGetCapabilitiesRequest(google.protobuf.message.Message):
    """Intentionally empty."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___ControllerGetCapabilitiesRequest = ControllerGetCapabilitiesRequest

class ControllerGetCapabilitiesResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CAPABILITIES_FIELD_NUMBER: builtins.int
    @property
    def capabilities(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ControllerServiceCapability]:
        """All the capabilities that the controller service supports. This
        field is OPTIONAL.
        """
        pass
    def __init__(self,
        *,
        capabilities : typing.Optional[typing.Iterable[global___ControllerServiceCapability]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["capabilities",b"capabilities"]) -> None: ...
global___ControllerGetCapabilitiesResponse = ControllerGetCapabilitiesResponse

class ControllerServiceCapability(google.protobuf.message.Message):
    """Specifies a capability of the controller service."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class RPC(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class Type(_Type, metaclass=_TypeEnumTypeWrapper):
            pass
        class _Type:
            V = typing.NewType('V', builtins.int)
        class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Type.V], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
            UNKNOWN = ControllerServiceCapability.RPC.Type.V(0)
            CREATE_DELETE_VOLUME = ControllerServiceCapability.RPC.Type.V(1)
            PUBLISH_UNPUBLISH_VOLUME = ControllerServiceCapability.RPC.Type.V(2)
            LIST_VOLUMES = ControllerServiceCapability.RPC.Type.V(3)
            GET_CAPACITY = ControllerServiceCapability.RPC.Type.V(4)
            CREATE_DELETE_SNAPSHOT = ControllerServiceCapability.RPC.Type.V(5)
            """Currently the only way to consume a snapshot is to create
            a volume from it. Therefore plugins supporting
            CREATE_DELETE_SNAPSHOT MUST support creating volume from
            snapshot.
            """

            LIST_SNAPSHOTS = ControllerServiceCapability.RPC.Type.V(6)
            CLONE_VOLUME = ControllerServiceCapability.RPC.Type.V(7)
            """Plugins supporting volume cloning at the storage level MAY
            report this capability. The source volume MUST be managed by
            the same plugin. Not all volume sources and parameters
            combinations MAY work.
            """

            PUBLISH_READONLY = ControllerServiceCapability.RPC.Type.V(8)
            """Indicates the SP supports ControllerPublishVolume.readonly
            field.
            """

            EXPAND_VOLUME = ControllerServiceCapability.RPC.Type.V(9)
            """See VolumeExpansion for details."""

            LIST_VOLUMES_PUBLISHED_NODES = ControllerServiceCapability.RPC.Type.V(10)
            """Indicates the SP supports the
            ListVolumesResponse.entry.published_nodes field
            """

            VOLUME_CONDITION = ControllerServiceCapability.RPC.Type.V(11)
            """Indicates that the Controller service can report volume
            conditions.
            An SP MAY implement `VolumeCondition` in only the Controller
            Plugin, only the Node Plugin, or both.
            If `VolumeCondition` is implemented in both the Controller and
            Node Plugins, it SHALL report from different perspectives.
            If for some reason Controller and Node Plugins report
            misaligned volume conditions, CO SHALL assume the worst case
            is the truth.
            Note that, for alpha, `VolumeCondition` is intended be
            informative for humans only, not for automation.
            """

            GET_VOLUME = ControllerServiceCapability.RPC.Type.V(12)
            """Indicates the SP supports the ControllerGetVolume RPC.
            This enables COs to, for example, fetch per volume
            condition after a volume is provisioned.
            """

            SINGLE_NODE_MULTI_WRITER = ControllerServiceCapability.RPC.Type.V(13)
            """Indicates the SP supports the SINGLE_NODE_SINGLE_WRITER and/or
            SINGLE_NODE_MULTI_WRITER access modes.
            These access modes are intended to replace the
            SINGLE_NODE_WRITER access mode to clarify the number of writers
            for a volume on a single node. Plugins MUST accept and allow
            use of the SINGLE_NODE_WRITER access mode when either
            SINGLE_NODE_SINGLE_WRITER and/or SINGLE_NODE_MULTI_WRITER are
            supported, in order to permit older COs to continue working.
            """


        UNKNOWN = ControllerServiceCapability.RPC.Type.V(0)
        CREATE_DELETE_VOLUME = ControllerServiceCapability.RPC.Type.V(1)
        PUBLISH_UNPUBLISH_VOLUME = ControllerServiceCapability.RPC.Type.V(2)
        LIST_VOLUMES = ControllerServiceCapability.RPC.Type.V(3)
        GET_CAPACITY = ControllerServiceCapability.RPC.Type.V(4)
        CREATE_DELETE_SNAPSHOT = ControllerServiceCapability.RPC.Type.V(5)
        """Currently the only way to consume a snapshot is to create
        a volume from it. Therefore plugins supporting
        CREATE_DELETE_SNAPSHOT MUST support creating volume from
        snapshot.
        """

        LIST_SNAPSHOTS = ControllerServiceCapability.RPC.Type.V(6)
        CLONE_VOLUME = ControllerServiceCapability.RPC.Type.V(7)
        """Plugins supporting volume cloning at the storage level MAY
        report this capability. The source volume MUST be managed by
        the same plugin. Not all volume sources and parameters
        combinations MAY work.
        """

        PUBLISH_READONLY = ControllerServiceCapability.RPC.Type.V(8)
        """Indicates the SP supports ControllerPublishVolume.readonly
        field.
        """

        EXPAND_VOLUME = ControllerServiceCapability.RPC.Type.V(9)
        """See VolumeExpansion for details."""

        LIST_VOLUMES_PUBLISHED_NODES = ControllerServiceCapability.RPC.Type.V(10)
        """Indicates the SP supports the
        ListVolumesResponse.entry.published_nodes field
        """

        VOLUME_CONDITION = ControllerServiceCapability.RPC.Type.V(11)
        """Indicates that the Controller service can report volume
        conditions.
        An SP MAY implement `VolumeCondition` in only the Controller
        Plugin, only the Node Plugin, or both.
        If `VolumeCondition` is implemented in both the Controller and
        Node Plugins, it SHALL report from different perspectives.
        If for some reason Controller and Node Plugins report
        misaligned volume conditions, CO SHALL assume the worst case
        is the truth.
        Note that, for alpha, `VolumeCondition` is intended be
        informative for humans only, not for automation.
        """

        GET_VOLUME = ControllerServiceCapability.RPC.Type.V(12)
        """Indicates the SP supports the ControllerGetVolume RPC.
        This enables COs to, for example, fetch per volume
        condition after a volume is provisioned.
        """

        SINGLE_NODE_MULTI_WRITER = ControllerServiceCapability.RPC.Type.V(13)
        """Indicates the SP supports the SINGLE_NODE_SINGLE_WRITER and/or
        SINGLE_NODE_MULTI_WRITER access modes.
        These access modes are intended to replace the
        SINGLE_NODE_WRITER access mode to clarify the number of writers
        for a volume on a single node. Plugins MUST accept and allow
        use of the SINGLE_NODE_WRITER access mode when either
        SINGLE_NODE_SINGLE_WRITER and/or SINGLE_NODE_MULTI_WRITER are
        supported, in order to permit older COs to continue working.
        """


        TYPE_FIELD_NUMBER: builtins.int
        type: global___ControllerServiceCapability.RPC.Type.V = ...
        def __init__(self,
            *,
            type : global___ControllerServiceCapability.RPC.Type.V = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["type",b"type"]) -> None: ...

    RPC_FIELD_NUMBER: builtins.int
    @property
    def rpc(self) -> global___ControllerServiceCapability.RPC:
        """RPC that the controller supports."""
        pass
    def __init__(self,
        *,
        rpc : typing.Optional[global___ControllerServiceCapability.RPC] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["rpc",b"rpc","type",b"type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["rpc",b"rpc","type",b"type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["rpc"]]: ...
global___ControllerServiceCapability = ControllerServiceCapability

class CreateSnapshotRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class SecretsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class ParametersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    SOURCE_VOLUME_ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    SECRETS_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    source_volume_id: typing.Text = ...
    """The ID of the source volume to be snapshotted.
    This field is REQUIRED.
    """

    name: typing.Text = ...
    """The suggested name for the snapshot. This field is REQUIRED for
    idempotency.
    Any Unicode string that conforms to the length limit is allowed
    except those containing the following banned characters:
    U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
    (These are control characters other than commonly used whitespace.)
    """

    @property
    def secrets(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Secrets required by plugin to complete snapshot creation request.
        This field is OPTIONAL. Refer to the `Secrets Requirements`
        section on how to use this field.
        """
        pass
    @property
    def parameters(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Plugin specific parameters passed in as opaque key-value pairs.
        This field is OPTIONAL. The Plugin is responsible for parsing and
        validating these parameters. COs will treat these as opaque.
        Use cases for opaque parameters:
        - Specify a policy to automatically clean up the snapshot.
        - Specify an expiration date for the snapshot.
        - Specify whether the snapshot is readonly or read/write.
        - Specify if the snapshot should be replicated to some place.
        - Specify primary or secondary for replication systems that
          support snapshotting only on primary.
        """
        pass
    def __init__(self,
        *,
        source_volume_id : typing.Text = ...,
        name : typing.Text = ...,
        secrets : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        parameters : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name","parameters",b"parameters","secrets",b"secrets","source_volume_id",b"source_volume_id"]) -> None: ...
global___CreateSnapshotRequest = CreateSnapshotRequest

class CreateSnapshotResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SNAPSHOT_FIELD_NUMBER: builtins.int
    @property
    def snapshot(self) -> global___Snapshot:
        """Contains all attributes of the newly created snapshot that are
        relevant to the CO along with information required by the Plugin
        to uniquely identify the snapshot. This field is REQUIRED.
        """
        pass
    def __init__(self,
        *,
        snapshot : typing.Optional[global___Snapshot] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["snapshot",b"snapshot"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["snapshot",b"snapshot"]) -> None: ...
global___CreateSnapshotResponse = CreateSnapshotResponse

class Snapshot(google.protobuf.message.Message):
    """Information about a specific snapshot."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SIZE_BYTES_FIELD_NUMBER: builtins.int
    SNAPSHOT_ID_FIELD_NUMBER: builtins.int
    SOURCE_VOLUME_ID_FIELD_NUMBER: builtins.int
    CREATION_TIME_FIELD_NUMBER: builtins.int
    READY_TO_USE_FIELD_NUMBER: builtins.int
    size_bytes: builtins.int = ...
    """This is the complete size of the snapshot in bytes. The purpose of
    this field is to give CO guidance on how much space is needed to
    create a volume from this snapshot. The size of the volume MUST NOT
    be less than the size of the source snapshot. This field is
    OPTIONAL. If this field is not set, it indicates that this size is
    unknown. The value of this field MUST NOT be negative and a size of
    zero means it is unspecified.
    """

    snapshot_id: typing.Text = ...
    """The identifier for this snapshot, generated by the plugin.
    This field is REQUIRED.
    This field MUST contain enough information to uniquely identify
    this specific snapshot vs all other snapshots supported by this
    plugin.
    This field SHALL be used by the CO in subsequent calls to refer to
    this snapshot.
    The SP is NOT responsible for global uniqueness of snapshot_id
    across multiple SPs.
    """

    source_volume_id: typing.Text = ...
    """Identity information for the source volume. Note that creating a
    snapshot from a snapshot is not supported here so the source has to
    be a volume. This field is REQUIRED.
    """

    @property
    def creation_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Timestamp when the point-in-time snapshot is taken on the storage
        system. This field is REQUIRED.
        """
        pass
    ready_to_use: builtins.bool = ...
    """Indicates if a snapshot is ready to use as a
    `volume_content_source` in a `CreateVolumeRequest`. The default
    value is false. This field is REQUIRED.
    """

    def __init__(self,
        *,
        size_bytes : builtins.int = ...,
        snapshot_id : typing.Text = ...,
        source_volume_id : typing.Text = ...,
        creation_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ready_to_use : builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["creation_time",b"creation_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["creation_time",b"creation_time","ready_to_use",b"ready_to_use","size_bytes",b"size_bytes","snapshot_id",b"snapshot_id","source_volume_id",b"source_volume_id"]) -> None: ...
global___Snapshot = Snapshot

class DeleteSnapshotRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class SecretsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    SNAPSHOT_ID_FIELD_NUMBER: builtins.int
    SECRETS_FIELD_NUMBER: builtins.int
    snapshot_id: typing.Text = ...
    """The ID of the snapshot to be deleted.
    This field is REQUIRED.
    """

    @property
    def secrets(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Secrets required by plugin to complete snapshot deletion request.
        This field is OPTIONAL. Refer to the `Secrets Requirements`
        section on how to use this field.
        """
        pass
    def __init__(self,
        *,
        snapshot_id : typing.Text = ...,
        secrets : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["secrets",b"secrets","snapshot_id",b"snapshot_id"]) -> None: ...
global___DeleteSnapshotRequest = DeleteSnapshotRequest

class DeleteSnapshotResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___DeleteSnapshotResponse = DeleteSnapshotResponse

class ListSnapshotsRequest(google.protobuf.message.Message):
    """List all snapshots on the storage system regardless of how they were
    created.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class SecretsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    MAX_ENTRIES_FIELD_NUMBER: builtins.int
    STARTING_TOKEN_FIELD_NUMBER: builtins.int
    SOURCE_VOLUME_ID_FIELD_NUMBER: builtins.int
    SNAPSHOT_ID_FIELD_NUMBER: builtins.int
    SECRETS_FIELD_NUMBER: builtins.int
    max_entries: builtins.int = ...
    """If specified (non-zero value), the Plugin MUST NOT return more
    entries than this number in the response. If the actual number of
    entries is more than this number, the Plugin MUST set `next_token`
    in the response which can be used to get the next page of entries
    in the subsequent `ListSnapshots` call. This field is OPTIONAL. If
    not specified (zero value), it means there is no restriction on the
    number of entries that can be returned.
    The value of this field MUST NOT be negative.
    """

    starting_token: typing.Text = ...
    """A token to specify where to start paginating. Set this field to
    `next_token` returned by a previous `ListSnapshots` call to get the
    next page of entries. This field is OPTIONAL.
    An empty string is equal to an unspecified field value.
    """

    source_volume_id: typing.Text = ...
    """Identity information for the source volume. This field is OPTIONAL.
    It can be used to list snapshots by volume.
    """

    snapshot_id: typing.Text = ...
    """Identity information for a specific snapshot. This field is
    OPTIONAL. It can be used to list only a specific snapshot.
    ListSnapshots will return with current snapshot information
    and will not block if the snapshot is being processed after
    it is cut.
    """

    @property
    def secrets(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Secrets required by plugin to complete ListSnapshot request.
        This field is OPTIONAL. Refer to the `Secrets Requirements`
        section on how to use this field.
        """
        pass
    def __init__(self,
        *,
        max_entries : builtins.int = ...,
        starting_token : typing.Text = ...,
        source_volume_id : typing.Text = ...,
        snapshot_id : typing.Text = ...,
        secrets : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["max_entries",b"max_entries","secrets",b"secrets","snapshot_id",b"snapshot_id","source_volume_id",b"source_volume_id","starting_token",b"starting_token"]) -> None: ...
global___ListSnapshotsRequest = ListSnapshotsRequest

class ListSnapshotsResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Entry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        SNAPSHOT_FIELD_NUMBER: builtins.int
        @property
        def snapshot(self) -> global___Snapshot: ...
        def __init__(self,
            *,
            snapshot : typing.Optional[global___Snapshot] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["snapshot",b"snapshot"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["snapshot",b"snapshot"]) -> None: ...

    ENTRIES_FIELD_NUMBER: builtins.int
    NEXT_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def entries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ListSnapshotsResponse.Entry]: ...
    next_token: typing.Text = ...
    """This token allows you to get the next page of entries for
    `ListSnapshots` request. If the number of entries is larger than
    `max_entries`, use the `next_token` as a value for the
    `starting_token` field in the next `ListSnapshots` request. This
    field is OPTIONAL.
    An empty string is equal to an unspecified field value.
    """

    def __init__(self,
        *,
        entries : typing.Optional[typing.Iterable[global___ListSnapshotsResponse.Entry]] = ...,
        next_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["entries",b"entries","next_token",b"next_token"]) -> None: ...
global___ListSnapshotsResponse = ListSnapshotsResponse

class ControllerExpandVolumeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class SecretsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    VOLUME_ID_FIELD_NUMBER: builtins.int
    CAPACITY_RANGE_FIELD_NUMBER: builtins.int
    SECRETS_FIELD_NUMBER: builtins.int
    VOLUME_CAPABILITY_FIELD_NUMBER: builtins.int
    volume_id: typing.Text = ...
    """The ID of the volume to expand. This field is REQUIRED."""

    @property
    def capacity_range(self) -> global___CapacityRange:
        """This allows CO to specify the capacity requirements of the volume
        after expansion. This field is REQUIRED.
        """
        pass
    @property
    def secrets(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Secrets required by the plugin for expanding the volume.
        This field is OPTIONAL.
        """
        pass
    @property
    def volume_capability(self) -> global___VolumeCapability:
        """Volume capability describing how the CO intends to use this volume.
        This allows SP to determine if volume is being used as a block
        device or mounted file system. For example - if volume is
        being used as a block device - the SP MAY set
        node_expansion_required to false in ControllerExpandVolumeResponse
        to skip invocation of NodeExpandVolume on the node by the CO.
        This is an OPTIONAL field.
        """
        pass
    def __init__(self,
        *,
        volume_id : typing.Text = ...,
        capacity_range : typing.Optional[global___CapacityRange] = ...,
        secrets : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        volume_capability : typing.Optional[global___VolumeCapability] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["capacity_range",b"capacity_range","volume_capability",b"volume_capability"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["capacity_range",b"capacity_range","secrets",b"secrets","volume_capability",b"volume_capability","volume_id",b"volume_id"]) -> None: ...
global___ControllerExpandVolumeRequest = ControllerExpandVolumeRequest

class ControllerExpandVolumeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CAPACITY_BYTES_FIELD_NUMBER: builtins.int
    NODE_EXPANSION_REQUIRED_FIELD_NUMBER: builtins.int
    capacity_bytes: builtins.int = ...
    """Capacity of volume after expansion. This field is REQUIRED."""

    node_expansion_required: builtins.bool = ...
    """Whether node expansion is required for the volume. When true
    the CO MUST make NodeExpandVolume RPC call on the node. This field
    is REQUIRED.
    """

    def __init__(self,
        *,
        capacity_bytes : builtins.int = ...,
        node_expansion_required : builtins.bool = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["capacity_bytes",b"capacity_bytes","node_expansion_required",b"node_expansion_required"]) -> None: ...
global___ControllerExpandVolumeResponse = ControllerExpandVolumeResponse

class NodeStageVolumeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class PublishContextEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class SecretsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class VolumeContextEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    VOLUME_ID_FIELD_NUMBER: builtins.int
    PUBLISH_CONTEXT_FIELD_NUMBER: builtins.int
    STAGING_TARGET_PATH_FIELD_NUMBER: builtins.int
    VOLUME_CAPABILITY_FIELD_NUMBER: builtins.int
    SECRETS_FIELD_NUMBER: builtins.int
    VOLUME_CONTEXT_FIELD_NUMBER: builtins.int
    volume_id: typing.Text = ...
    """The ID of the volume to publish. This field is REQUIRED."""

    @property
    def publish_context(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """The CO SHALL set this field to the value returned by
        `ControllerPublishVolume` if the corresponding Controller Plugin
        has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
        left unset if the corresponding Controller Plugin does not have
        this capability. This is an OPTIONAL field.
        """
        pass
    staging_target_path: typing.Text = ...
    """The path to which the volume MAY be staged. It MUST be an
    absolute path in the root filesystem of the process serving this
    request, and MUST be a directory. The CO SHALL ensure that there
    is only one `staging_target_path` per volume. The CO SHALL ensure
    that the path is directory and that the process serving the
    request has `read` and `write` permission to that directory. The
    CO SHALL be responsible for creating the directory if it does not
    exist.
    This is a REQUIRED field.
    This field overrides the general CSI size limit.
    SP SHOULD support the maximum path length allowed by the operating
    system/filesystem, but, at a minimum, SP MUST accept a max path
    length of at least 128 bytes.
    """

    @property
    def volume_capability(self) -> global___VolumeCapability:
        """Volume capability describing how the CO intends to use this volume.
        SP MUST ensure the CO can use the staged volume as described.
        Otherwise SP MUST return the appropriate gRPC error code.
        This is a REQUIRED field.
        """
        pass
    @property
    def secrets(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Secrets required by plugin to complete node stage volume request.
        This field is OPTIONAL. Refer to the `Secrets Requirements`
        section on how to use this field.
        """
        pass
    @property
    def volume_context(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Volume context as returned by SP in
        CreateVolumeResponse.Volume.volume_context.
        This field is OPTIONAL and MUST match the volume_context of the
        volume identified by `volume_id`.
        """
        pass
    def __init__(self,
        *,
        volume_id : typing.Text = ...,
        publish_context : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        staging_target_path : typing.Text = ...,
        volume_capability : typing.Optional[global___VolumeCapability] = ...,
        secrets : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        volume_context : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["volume_capability",b"volume_capability"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["publish_context",b"publish_context","secrets",b"secrets","staging_target_path",b"staging_target_path","volume_capability",b"volume_capability","volume_context",b"volume_context","volume_id",b"volume_id"]) -> None: ...
global___NodeStageVolumeRequest = NodeStageVolumeRequest

class NodeStageVolumeResponse(google.protobuf.message.Message):
    """Intentionally empty."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___NodeStageVolumeResponse = NodeStageVolumeResponse

class NodeUnstageVolumeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    VOLUME_ID_FIELD_NUMBER: builtins.int
    STAGING_TARGET_PATH_FIELD_NUMBER: builtins.int
    volume_id: typing.Text = ...
    """The ID of the volume. This field is REQUIRED."""

    staging_target_path: typing.Text = ...
    """The path at which the volume was staged. It MUST be an absolute
    path in the root filesystem of the process serving this request.
    This is a REQUIRED field.
    This field overrides the general CSI size limit.
    SP SHOULD support the maximum path length allowed by the operating
    system/filesystem, but, at a minimum, SP MUST accept a max path
    length of at least 128 bytes.
    """

    def __init__(self,
        *,
        volume_id : typing.Text = ...,
        staging_target_path : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["staging_target_path",b"staging_target_path","volume_id",b"volume_id"]) -> None: ...
global___NodeUnstageVolumeRequest = NodeUnstageVolumeRequest

class NodeUnstageVolumeResponse(google.protobuf.message.Message):
    """Intentionally empty."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___NodeUnstageVolumeResponse = NodeUnstageVolumeResponse

class NodePublishVolumeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class PublishContextEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class SecretsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class VolumeContextEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    VOLUME_ID_FIELD_NUMBER: builtins.int
    PUBLISH_CONTEXT_FIELD_NUMBER: builtins.int
    STAGING_TARGET_PATH_FIELD_NUMBER: builtins.int
    TARGET_PATH_FIELD_NUMBER: builtins.int
    VOLUME_CAPABILITY_FIELD_NUMBER: builtins.int
    READONLY_FIELD_NUMBER: builtins.int
    SECRETS_FIELD_NUMBER: builtins.int
    VOLUME_CONTEXT_FIELD_NUMBER: builtins.int
    volume_id: typing.Text = ...
    """The ID of the volume to publish. This field is REQUIRED."""

    @property
    def publish_context(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """The CO SHALL set this field to the value returned by
        `ControllerPublishVolume` if the corresponding Controller Plugin
        has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
        left unset if the corresponding Controller Plugin does not have
        this capability. This is an OPTIONAL field.
        """
        pass
    staging_target_path: typing.Text = ...
    """The path to which the volume was staged by `NodeStageVolume`.
    It MUST be an absolute path in the root filesystem of the process
    serving this request.
    It MUST be set if the Node Plugin implements the
    `STAGE_UNSTAGE_VOLUME` node capability.
    This is an OPTIONAL field.
    This field overrides the general CSI size limit.
    SP SHOULD support the maximum path length allowed by the operating
    system/filesystem, but, at a minimum, SP MUST accept a max path
    length of at least 128 bytes.
    """

    target_path: typing.Text = ...
    """The path to which the volume will be published. It MUST be an
    absolute path in the root filesystem of the process serving this
    request. The CO SHALL ensure uniqueness of target_path per volume.
    The CO SHALL ensure that the parent directory of this path exists
    and that the process serving the request has `read` and `write`
    permissions to that parent directory.
    For volumes with an access type of block, the SP SHALL place the
    block device at target_path.
    For volumes with an access type of mount, the SP SHALL place the
    mounted directory at target_path.
    Creation of target_path is the responsibility of the SP.
    This is a REQUIRED field.
    This field overrides the general CSI size limit.
    SP SHOULD support the maximum path length allowed by the operating
    system/filesystem, but, at a minimum, SP MUST accept a max path
    length of at least 128 bytes.
    """

    @property
    def volume_capability(self) -> global___VolumeCapability:
        """Volume capability describing how the CO intends to use this volume.
        SP MUST ensure the CO can use the published volume as described.
        Otherwise SP MUST return the appropriate gRPC error code.
        This is a REQUIRED field.
        """
        pass
    readonly: builtins.bool = ...
    """Indicates SP MUST publish the volume in readonly mode.
    This field is REQUIRED.
    """

    @property
    def secrets(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Secrets required by plugin to complete node publish volume request.
        This field is OPTIONAL. Refer to the `Secrets Requirements`
        section on how to use this field.
        """
        pass
    @property
    def volume_context(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Volume context as returned by SP in
        CreateVolumeResponse.Volume.volume_context.
        This field is OPTIONAL and MUST match the volume_context of the
        volume identified by `volume_id`.
        """
        pass
    def __init__(self,
        *,
        volume_id : typing.Text = ...,
        publish_context : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        staging_target_path : typing.Text = ...,
        target_path : typing.Text = ...,
        volume_capability : typing.Optional[global___VolumeCapability] = ...,
        readonly : builtins.bool = ...,
        secrets : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        volume_context : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["volume_capability",b"volume_capability"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["publish_context",b"publish_context","readonly",b"readonly","secrets",b"secrets","staging_target_path",b"staging_target_path","target_path",b"target_path","volume_capability",b"volume_capability","volume_context",b"volume_context","volume_id",b"volume_id"]) -> None: ...
global___NodePublishVolumeRequest = NodePublishVolumeRequest

class NodePublishVolumeResponse(google.protobuf.message.Message):
    """Intentionally empty."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___NodePublishVolumeResponse = NodePublishVolumeResponse

class NodeUnpublishVolumeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    VOLUME_ID_FIELD_NUMBER: builtins.int
    TARGET_PATH_FIELD_NUMBER: builtins.int
    volume_id: typing.Text = ...
    """The ID of the volume. This field is REQUIRED."""

    target_path: typing.Text = ...
    """The path at which the volume was published. It MUST be an absolute
    path in the root filesystem of the process serving this request.
    The SP MUST delete the file or directory it created at this path.
    This is a REQUIRED field.
    This field overrides the general CSI size limit.
    SP SHOULD support the maximum path length allowed by the operating
    system/filesystem, but, at a minimum, SP MUST accept a max path
    length of at least 128 bytes.
    """

    def __init__(self,
        *,
        volume_id : typing.Text = ...,
        target_path : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["target_path",b"target_path","volume_id",b"volume_id"]) -> None: ...
global___NodeUnpublishVolumeRequest = NodeUnpublishVolumeRequest

class NodeUnpublishVolumeResponse(google.protobuf.message.Message):
    """Intentionally empty."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___NodeUnpublishVolumeResponse = NodeUnpublishVolumeResponse

class NodeGetVolumeStatsRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    VOLUME_ID_FIELD_NUMBER: builtins.int
    VOLUME_PATH_FIELD_NUMBER: builtins.int
    STAGING_TARGET_PATH_FIELD_NUMBER: builtins.int
    volume_id: typing.Text = ...
    """The ID of the volume. This field is REQUIRED."""

    volume_path: typing.Text = ...
    """It can be any valid path where volume was previously
    staged or published.
    It MUST be an absolute path in the root filesystem of
    the process serving this request.
    This is a REQUIRED field.
    This field overrides the general CSI size limit.
    SP SHOULD support the maximum path length allowed by the operating
    system/filesystem, but, at a minimum, SP MUST accept a max path
    length of at least 128 bytes.
    """

    staging_target_path: typing.Text = ...
    """The path where the volume is staged, if the plugin has the
    STAGE_UNSTAGE_VOLUME capability, otherwise empty.
    If not empty, it MUST be an absolute path in the root
    filesystem of the process serving this request.
    This field is OPTIONAL.
    This field overrides the general CSI size limit.
    SP SHOULD support the maximum path length allowed by the operating
    system/filesystem, but, at a minimum, SP MUST accept a max path
    length of at least 128 bytes.
    """

    def __init__(self,
        *,
        volume_id : typing.Text = ...,
        volume_path : typing.Text = ...,
        staging_target_path : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["staging_target_path",b"staging_target_path","volume_id",b"volume_id","volume_path",b"volume_path"]) -> None: ...
global___NodeGetVolumeStatsRequest = NodeGetVolumeStatsRequest

class NodeGetVolumeStatsResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    USAGE_FIELD_NUMBER: builtins.int
    VOLUME_CONDITION_FIELD_NUMBER: builtins.int
    @property
    def usage(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___VolumeUsage]:
        """This field is OPTIONAL."""
        pass
    @property
    def volume_condition(self) -> global___VolumeCondition:
        """Information about the current condition of the volume.
        This field is OPTIONAL.
        This field MUST be specified if the VOLUME_CONDITION node
        capability is supported.
        """
        pass
    def __init__(self,
        *,
        usage : typing.Optional[typing.Iterable[global___VolumeUsage]] = ...,
        volume_condition : typing.Optional[global___VolumeCondition] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["volume_condition",b"volume_condition"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["usage",b"usage","volume_condition",b"volume_condition"]) -> None: ...
global___NodeGetVolumeStatsResponse = NodeGetVolumeStatsResponse

class VolumeUsage(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Unit(_Unit, metaclass=_UnitEnumTypeWrapper):
        pass
    class _Unit:
        V = typing.NewType('V', builtins.int)
    class _UnitEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Unit.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNKNOWN = VolumeUsage.Unit.V(0)
        BYTES = VolumeUsage.Unit.V(1)
        INODES = VolumeUsage.Unit.V(2)

    UNKNOWN = VolumeUsage.Unit.V(0)
    BYTES = VolumeUsage.Unit.V(1)
    INODES = VolumeUsage.Unit.V(2)

    AVAILABLE_FIELD_NUMBER: builtins.int
    TOTAL_FIELD_NUMBER: builtins.int
    USED_FIELD_NUMBER: builtins.int
    UNIT_FIELD_NUMBER: builtins.int
    available: builtins.int = ...
    """The available capacity in specified Unit. This field is OPTIONAL.
    The value of this field MUST NOT be negative.
    """

    total: builtins.int = ...
    """The total capacity in specified Unit. This field is REQUIRED.
    The value of this field MUST NOT be negative.
    """

    used: builtins.int = ...
    """The used capacity in specified Unit. This field is OPTIONAL.
    The value of this field MUST NOT be negative.
    """

    unit: global___VolumeUsage.Unit.V = ...
    """Units by which values are measured. This field is REQUIRED."""

    def __init__(self,
        *,
        available : builtins.int = ...,
        total : builtins.int = ...,
        used : builtins.int = ...,
        unit : global___VolumeUsage.Unit.V = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["available",b"available","total",b"total","unit",b"unit","used",b"used"]) -> None: ...
global___VolumeUsage = VolumeUsage

class VolumeCondition(google.protobuf.message.Message):
    """VolumeCondition represents the current condition of a volume."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ABNORMAL_FIELD_NUMBER: builtins.int
    MESSAGE_FIELD_NUMBER: builtins.int
    abnormal: builtins.bool = ...
    """Normal volumes are available for use and operating optimally.
    An abnormal volume does not meet these criteria.
    This field is REQUIRED.
    """

    message: typing.Text = ...
    """The message describing the condition of the volume.
    This field is REQUIRED.
    """

    def __init__(self,
        *,
        abnormal : builtins.bool = ...,
        message : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["abnormal",b"abnormal","message",b"message"]) -> None: ...
global___VolumeCondition = VolumeCondition

class NodeGetCapabilitiesRequest(google.protobuf.message.Message):
    """Intentionally empty."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___NodeGetCapabilitiesRequest = NodeGetCapabilitiesRequest

class NodeGetCapabilitiesResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CAPABILITIES_FIELD_NUMBER: builtins.int
    @property
    def capabilities(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___NodeServiceCapability]:
        """All the capabilities that the node service supports. This field
        is OPTIONAL.
        """
        pass
    def __init__(self,
        *,
        capabilities : typing.Optional[typing.Iterable[global___NodeServiceCapability]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["capabilities",b"capabilities"]) -> None: ...
global___NodeGetCapabilitiesResponse = NodeGetCapabilitiesResponse

class NodeServiceCapability(google.protobuf.message.Message):
    """Specifies a capability of the node service."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class RPC(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class Type(_Type, metaclass=_TypeEnumTypeWrapper):
            pass
        class _Type:
            V = typing.NewType('V', builtins.int)
        class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Type.V], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
            UNKNOWN = NodeServiceCapability.RPC.Type.V(0)
            STAGE_UNSTAGE_VOLUME = NodeServiceCapability.RPC.Type.V(1)
            GET_VOLUME_STATS = NodeServiceCapability.RPC.Type.V(2)
            """If Plugin implements GET_VOLUME_STATS capability
            then it MUST implement NodeGetVolumeStats RPC
            call for fetching volume statistics.
            """

            EXPAND_VOLUME = NodeServiceCapability.RPC.Type.V(3)
            """See VolumeExpansion for details."""

            VOLUME_CONDITION = NodeServiceCapability.RPC.Type.V(4)
            """Indicates that the Node service can report volume conditions.
            An SP MAY implement `VolumeCondition` in only the Node
            Plugin, only the Controller Plugin, or both.
            If `VolumeCondition` is implemented in both the Node and
            Controller Plugins, it SHALL report from different
            perspectives.
            If for some reason Node and Controller Plugins report
            misaligned volume conditions, CO SHALL assume the worst case
            is the truth.
            Note that, for alpha, `VolumeCondition` is intended to be
            informative for humans only, not for automation.
            """

            SINGLE_NODE_MULTI_WRITER = NodeServiceCapability.RPC.Type.V(5)
            """Indicates the SP supports the SINGLE_NODE_SINGLE_WRITER and/or
            SINGLE_NODE_MULTI_WRITER access modes.
            These access modes are intended to replace the
            SINGLE_NODE_WRITER access mode to clarify the number of writers
            for a volume on a single node. Plugins MUST accept and allow
            use of the SINGLE_NODE_WRITER access mode (subject to the
            processing rules for NodePublishVolume), when either
            SINGLE_NODE_SINGLE_WRITER and/or SINGLE_NODE_MULTI_WRITER are
            supported, in order to permit older COs to continue working.
            """

            VOLUME_MOUNT_GROUP = NodeServiceCapability.RPC.Type.V(6)
            """Indicates that Node service supports mounting volumes
            with provided volume group identifier during node stage
            or node publish RPC calls.
            """


        UNKNOWN = NodeServiceCapability.RPC.Type.V(0)
        STAGE_UNSTAGE_VOLUME = NodeServiceCapability.RPC.Type.V(1)
        GET_VOLUME_STATS = NodeServiceCapability.RPC.Type.V(2)
        """If Plugin implements GET_VOLUME_STATS capability
        then it MUST implement NodeGetVolumeStats RPC
        call for fetching volume statistics.
        """

        EXPAND_VOLUME = NodeServiceCapability.RPC.Type.V(3)
        """See VolumeExpansion for details."""

        VOLUME_CONDITION = NodeServiceCapability.RPC.Type.V(4)
        """Indicates that the Node service can report volume conditions.
        An SP MAY implement `VolumeCondition` in only the Node
        Plugin, only the Controller Plugin, or both.
        If `VolumeCondition` is implemented in both the Node and
        Controller Plugins, it SHALL report from different
        perspectives.
        If for some reason Node and Controller Plugins report
        misaligned volume conditions, CO SHALL assume the worst case
        is the truth.
        Note that, for alpha, `VolumeCondition` is intended to be
        informative for humans only, not for automation.
        """

        SINGLE_NODE_MULTI_WRITER = NodeServiceCapability.RPC.Type.V(5)
        """Indicates the SP supports the SINGLE_NODE_SINGLE_WRITER and/or
        SINGLE_NODE_MULTI_WRITER access modes.
        These access modes are intended to replace the
        SINGLE_NODE_WRITER access mode to clarify the number of writers
        for a volume on a single node. Plugins MUST accept and allow
        use of the SINGLE_NODE_WRITER access mode (subject to the
        processing rules for NodePublishVolume), when either
        SINGLE_NODE_SINGLE_WRITER and/or SINGLE_NODE_MULTI_WRITER are
        supported, in order to permit older COs to continue working.
        """

        VOLUME_MOUNT_GROUP = NodeServiceCapability.RPC.Type.V(6)
        """Indicates that Node service supports mounting volumes
        with provided volume group identifier during node stage
        or node publish RPC calls.
        """


        TYPE_FIELD_NUMBER: builtins.int
        type: global___NodeServiceCapability.RPC.Type.V = ...
        def __init__(self,
            *,
            type : global___NodeServiceCapability.RPC.Type.V = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["type",b"type"]) -> None: ...

    RPC_FIELD_NUMBER: builtins.int
    @property
    def rpc(self) -> global___NodeServiceCapability.RPC:
        """RPC that the controller supports."""
        pass
    def __init__(self,
        *,
        rpc : typing.Optional[global___NodeServiceCapability.RPC] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["rpc",b"rpc","type",b"type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["rpc",b"rpc","type",b"type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["rpc"]]: ...
global___NodeServiceCapability = NodeServiceCapability

class NodeGetInfoRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___NodeGetInfoRequest = NodeGetInfoRequest

class NodeGetInfoResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NODE_ID_FIELD_NUMBER: builtins.int
    MAX_VOLUMES_PER_NODE_FIELD_NUMBER: builtins.int
    ACCESSIBLE_TOPOLOGY_FIELD_NUMBER: builtins.int
    node_id: typing.Text = ...
    """The identifier of the node as understood by the SP.
    This field is REQUIRED.
    This field MUST contain enough information to uniquely identify
    this specific node vs all other nodes supported by this plugin.
    This field SHALL be used by the CO in subsequent calls, including
    `ControllerPublishVolume`, to refer to this node.
    The SP is NOT responsible for global uniqueness of node_id across
    multiple SPs.
    This field overrides the general CSI size limit.
    The size of this field SHALL NOT exceed 256 bytes. The general
    CSI size limit, 128 byte, is RECOMMENDED for best backwards
    compatibility.
    """

    max_volumes_per_node: builtins.int = ...
    """Maximum number of volumes that controller can publish to the node.
    If value is not set or zero CO SHALL decide how many volumes of
    this type can be published by the controller to the node. The
    plugin MUST NOT set negative values here.
    This field is OPTIONAL.
    """

    @property
    def accessible_topology(self) -> global___Topology:
        """Specifies where (regions, zones, racks, etc.) the node is
        accessible from.
        A plugin that returns this field MUST also set the
        VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
        COs MAY use this information along with the topology information
        returned in CreateVolumeResponse to ensure that a given volume is
        accessible from a given node when scheduling workloads.
        This field is OPTIONAL. If it is not specified, the CO MAY assume
        the node is not subject to any topological constraint, and MAY
        schedule workloads that reference any volume V, such that there are
        no topological constraints declared for V.

        Example 1:
          accessible_topology =
            {"region": "R1", "zone": "Z2"}
        Indicates the node exists within the "region" "R1" and the "zone"
        "Z2".
        """
        pass
    def __init__(self,
        *,
        node_id : typing.Text = ...,
        max_volumes_per_node : builtins.int = ...,
        accessible_topology : typing.Optional[global___Topology] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["accessible_topology",b"accessible_topology"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["accessible_topology",b"accessible_topology","max_volumes_per_node",b"max_volumes_per_node","node_id",b"node_id"]) -> None: ...
global___NodeGetInfoResponse = NodeGetInfoResponse

class NodeExpandVolumeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class SecretsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    VOLUME_ID_FIELD_NUMBER: builtins.int
    VOLUME_PATH_FIELD_NUMBER: builtins.int
    CAPACITY_RANGE_FIELD_NUMBER: builtins.int
    STAGING_TARGET_PATH_FIELD_NUMBER: builtins.int
    VOLUME_CAPABILITY_FIELD_NUMBER: builtins.int
    SECRETS_FIELD_NUMBER: builtins.int
    volume_id: typing.Text = ...
    """The ID of the volume. This field is REQUIRED."""

    volume_path: typing.Text = ...
    """The path on which volume is available. This field is REQUIRED.
    This field overrides the general CSI size limit.
    SP SHOULD support the maximum path length allowed by the operating
    system/filesystem, but, at a minimum, SP MUST accept a max path
    length of at least 128 bytes.
    """

    @property
    def capacity_range(self) -> global___CapacityRange:
        """This allows CO to specify the capacity requirements of the volume
        after expansion. If capacity_range is omitted then a plugin MAY
        inspect the file system of the volume to determine the maximum
        capacity to which the volume can be expanded. In such cases a
        plugin MAY expand the volume to its maximum capacity.
        This field is OPTIONAL.
        """
        pass
    staging_target_path: typing.Text = ...
    """The path where the volume is staged, if the plugin has the
    STAGE_UNSTAGE_VOLUME capability, otherwise empty.
    If not empty, it MUST be an absolute path in the root
    filesystem of the process serving this request.
    This field is OPTIONAL.
    This field overrides the general CSI size limit.
    SP SHOULD support the maximum path length allowed by the operating
    system/filesystem, but, at a minimum, SP MUST accept a max path
    length of at least 128 bytes.
    """

    @property
    def volume_capability(self) -> global___VolumeCapability:
        """Volume capability describing how the CO intends to use this volume.
        This allows SP to determine if volume is being used as a block
        device or mounted file system. For example - if volume is being
        used as a block device the SP MAY choose to skip expanding the
        filesystem in NodeExpandVolume implementation but still perform
        rest of the housekeeping needed for expanding the volume. If
        volume_capability is omitted the SP MAY determine
        access_type from given volume_path for the volume and perform
        node expansion. This is an OPTIONAL field.
        """
        pass
    @property
    def secrets(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Secrets required by plugin to complete node expand volume request.
        This field is OPTIONAL. Refer to the `Secrets Requirements`
        section on how to use this field.
        """
        pass
    def __init__(self,
        *,
        volume_id : typing.Text = ...,
        volume_path : typing.Text = ...,
        capacity_range : typing.Optional[global___CapacityRange] = ...,
        staging_target_path : typing.Text = ...,
        volume_capability : typing.Optional[global___VolumeCapability] = ...,
        secrets : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["capacity_range",b"capacity_range","volume_capability",b"volume_capability"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["capacity_range",b"capacity_range","secrets",b"secrets","staging_target_path",b"staging_target_path","volume_capability",b"volume_capability","volume_id",b"volume_id","volume_path",b"volume_path"]) -> None: ...
global___NodeExpandVolumeRequest = NodeExpandVolumeRequest

class NodeExpandVolumeResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CAPACITY_BYTES_FIELD_NUMBER: builtins.int
    capacity_bytes: builtins.int = ...
    """The capacity of the volume in bytes. This field is OPTIONAL."""

    def __init__(self,
        *,
        capacity_bytes : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["capacity_bytes",b"capacity_bytes"]) -> None: ...
global___NodeExpandVolumeResponse = NodeExpandVolumeResponse

alpha_enum: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[google.protobuf.descriptor_pb2.EnumOptions, builtins.bool] = ...
"""Indicates that this enum is OPTIONAL and part of an experimental
API that may be deprecated and eventually removed between minor
releases.
"""

alpha_enum_value: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[google.protobuf.descriptor_pb2.EnumValueOptions, builtins.bool] = ...
"""Indicates that this enum value is OPTIONAL and part of an
experimental API that may be deprecated and eventually removed
between minor releases.
"""

csi_secret: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[google.protobuf.descriptor_pb2.FieldOptions, builtins.bool] = ...
"""Indicates that a field MAY contain information that is sensitive
and MUST be treated as such (e.g. not logged).
"""

alpha_field: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[google.protobuf.descriptor_pb2.FieldOptions, builtins.bool] = ...
"""Indicates that this field is OPTIONAL and part of an experimental
API that may be deprecated and eventually removed between minor
releases.
"""

alpha_message: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[google.protobuf.descriptor_pb2.MessageOptions, builtins.bool] = ...
"""Indicates that this message is OPTIONAL and part of an experimental
API that may be deprecated and eventually removed between minor
releases.
"""

alpha_method: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[google.protobuf.descriptor_pb2.MethodOptions, builtins.bool] = ...
"""Indicates that this method is OPTIONAL and part of an experimental
API that may be deprecated and eventually removed between minor
releases.
"""

alpha_service: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[google.protobuf.descriptor_pb2.ServiceOptions, builtins.bool] = ...
"""Indicates that this service is OPTIONAL and part of an experimental
API that may be deprecated and eventually removed between minor
releases.
"""
